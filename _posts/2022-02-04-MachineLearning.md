---
layout:     post                    # 使用的布局（不需要改）
title:      MachineLearning               # 标题 
subtitle:   机器学习和深度学习 #副标题
date:       2022-02-04              # 时间
author:     Fu Xiaohang                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 机器学习
    - 深度学习
---

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

# 1 机器学习

## 1.1 分类

### 1.1.1 Logistic



### 1.1.2 KNN

https://zhuanlan.zhihu.com/p/25994179

### 1.1.3 NaiveBayes

&emsp;&emsp;朴素贝叶斯算法是基于贝叶斯公式的，即在已知特征值的情况下，计算某一类的概率，
$$
P(类别|特征)=\frac{P(特征|类别)P(类别)}{P(特征)}
$$
左边直接求是不好求的，但是右边三个都能直接求，

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/image-20211206160631622.png" alt="image-20211206160631622" style="zoom:50%;" />

已知某男生的四个特征分别是不帅，性格不好，身高矮，不上进，要求女生嫁的概率，

```
P(嫁|不帅、性格不好、身高矮、不上进)=P(不帅、性格不好、身高矮、不上进|嫁)P(嫁)/P(不帅、性格不好、身高矮、不上进)
```

朴素贝叶斯有一个前提，是各个特征之间要相互独立，这样右边才能通过连乘计算，

```
P(不帅、性格不好、身高矮、不上进|嫁)=P(不帅|嫁)*P(性格不好|嫁)*P(身高矮|嫁)*P(不上进|嫁)*P(嫁)
P(不帅、性格不好、身高矮、不上进)=P(不帅)*P(性格不好)*P(身高矮)*P(不上进)
P(嫁)=6/12=1/2
P(不帅|嫁)=3/6=1/2
P(性格不好|嫁)=1/6
P(不帅)=4/12=1/3
...
```

而这个前提在实际应用中往往是不成立的，在特征个数比较多或者特征之间相关性较大时，分类效果不好；而在特征相关性较小时，朴素贝叶斯性能最为良好。对于独立性这一点，有**贝叶斯信念网络**、半朴素贝叶斯等算法进行改进。

&emsp;&emsp;对于概率P，原始计算为，
$$
P=\frac{某类别的样本数}{样本总数}
$$
而当某类别的样本数为0时，会导致概率为0，进而导致贝叶斯公式中的计算也为0，为了防止概率为0，引入**拉普拉斯平滑**，
$$
P=\frac{某类别的样本数+1}{样本总数+种类的个数}
$$
**应用**

- 垃圾邮件过滤(TF-IDF提取关键词作特征)，比如很多垃圾邮件的发件人是service
- 分词时，根据语料库中的概率，选择最符合上下文语义的分词方式
- Google单词拼写检查与纠正，在已知拼写错误时，根据语料库中的概率，选择最可能正确的纠正词，而一开始检查的过程可以使用编辑距离等方式
- 实习项目Android Package Readable Detect(N-Gram作特征)



参考：[带你理解朴素贝叶斯分类算法](https://zhuanlan.zhihu.com/p/26262151)

### 1.1.4 SVM

### 1.1.5 DecisionTree

&emsp;&emsp;决策树是一个树结构，每一个非叶节点表示一个对一个特征的测试，该节点的分支代表这个特征在某个值域上的输出，叶子节点代表一个输出类别。某个特征可能出现在多个非叶节点中。如下图所示，使用决策树进行决策的过程就是从根节点开始，测试待分类项中相应的特征，并按照其值选择输出分支，直到到达叶子节点，将叶子节点存放的类别作为决策结果。

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/image-20211206140012659.png" alt="image-20211206140012659" style="zoom: 50%;" />

决策树构建，关键在于每一层选择哪一个特征，选择的原则是使分支中尽可能是同一个类别，即纯度更高，判断纯度的方法有ID3算法和C4.5算法。

#### 1.1.5.1 ID3

&emsp;&emsp;用信息增益作为纯度的度量，信息增益=信息熵-条件熵，信息熵代表随机变量的复杂度，条件熵代表在某一个条件下，随机变量的复杂度。

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/image-20211206141603732.png" alt="image-20211206141603732" style="zoom:50%;" />

设当前样本集合D中第k类样本所占比例为p<sub>k</sub>，则D的信息熵定义为，
$$
Ent(D)=-∑p_{k}log_{2}p_{k}
$$
对上图，好瓜有8个，占比8/17，坏瓜有9个，占比9/17，则其信息熵为，

```
Ent(D)=-((8/17)*log2(8/17)+(9/17)*log2(9/17))=0.998
```

对样本集D中某类特征a，取值为a<sub>v</sub>时的样本集合记为D<sub>v</sub>，则该特征的条件熵为，
$$
I(a)=∑\frac{|D_{v}|}{|D|}Ent(D_{v})
$$
该特征的信息增益即为，其中，对于不同的特征，Ent(D)是一样的，
$$
Gain(D,a)=Ent(D)-I(a)
$$
对于色泽，共有三种可能的取值{青绿，乌黑，浅白}，青绿代表的编号为{1, 4, 6, 10, 13, 17}，3好瓜3坏瓜，

```
Ent(青绿)=-((3/6)*log2(3/6)+(3/6)*log2(3/6))=1
```

乌黑代表的编号为{2, 3, 7, 8, 9, 15}，4好瓜2坏瓜，浅白代表的编号为{5, 11, 12, 14, 16}，1好瓜4坏瓜，

```
Ent(乌黑)=-((4/6)*log2(4/6)+(2/6)*log2(2/6))=0.918
Ent(浅白)=-((1/5)*log2(1/5)+(4/5)*log2(4/5))=0.722
```

则对于特征色泽，其条件熵为，

```
I(色泽)=((6/17)*Ent(青绿)+(6/17)*Ent(乌黑)+(5/17)*Ent(浅白)
      =((6/17)*1+(6/17)*0.918+(5/17)*0.722)
      =0.889
```

其信息增益为，

```
Gain(D,色泽)=Ent(D)-I(色泽)=0.998-0.889=0.109
```

同理，可以计算其他特征的信息增益，选择最大的作为当前节点的特征，然后进行划分，继续计算选择。

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/image-20211206143948531.png" alt="image-20211206143948531" style="zoom: 50%;" />

#### 1.1.5.2 C4.5

&emsp;&emsp;ID3中，信息增益准则其实是对可取值数目较多的属性有所偏好，假如我们把数据集中的“编号”也作为一个候选划分属性，我们可以算出“编号”的信息增益是0.998，因为每一个样本的编号都是不同的(由于编号独特唯一，条件熵为0了，每一个结点中只有一类，纯度非常高)，也就是说，来了一个预测样本，只要知道编号，其它特征就没有用了，这样生成的决策树显然不具有泛化能力。于是我们就引入了信息增益率来选择最优划分特征。
$$
Gain\_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}
$$
是该特征的信息增益Gain(D,a)除以该特征的一个固有值IV(a)，该值对应于该特征可能的取值数量，
$$
IV(a)=-∑\frac{|D_{v}|}{|D|}log_{2}\frac{|D_{v}|}{|D|}
$$
这样，信息增益率准则其实对可取类别数目较少的特征有所偏好。因此，C4.5算法不直接选择信息增益率最大的特征，而是先找出**信息增益**高于平均水平的特征(这样保证了大部分好的特征)，再从中选择**信息增益率**最高的(保证了不会出现编号特征这种极端的情况)。

#### 1.1.5.3 避免过拟合

&emsp;&emsp;生成的树可能会过拟合，分支太多，有些分支可能反映由于噪声或异常值引起的异常，避免过拟合的方法：

- 预调整：当度量值低于阈值时，不要分割节点，提前停止树的构建，但是难以选择合适的阈值
- 后期修剪：从一棵构建好的树上剪枝，得到一系列不同的修剪过的树，使用一组不同于训练数据的数据来决定哪个是“最佳修剪树”




参考：

- [深入浅出理解决策树算法（一）-核心思想](https://zhuanlan.zhihu.com/p/26703300)

- [深入浅出理解决策树算法（二）-ID3算法与C4.5算法](https://zhuanlan.zhihu.com/p/26760551)

### 1.1.6 RandomForest

详见[1.7.1 Bagging](###1.7.1 Bagging)

- 优点
  - 训练可以高度并行化，可以有效运行在大数据集上
  - 由于对决策树候选划分属性的采样，这样在样本特征维度较高的时候，仍然可以高效的训练模型
  - 由于有了样本和属性的采样，最终训练出来的模型泛化能力强
  - 可以输出各特征对预测目标的重要性(特征选择)
  - 对部分特征的缺失容忍度高
  - 袋外数据(未被采样的数据)可用作验证集来检验模型的有效性，不用额外划分数据集
- 缺点
  - 在某些噪声比较大的样本集上，随机森林容易陷入过拟合
  - 取值划分比较多的特征容易对随机森林的决策产生更大的影响，从而影响拟合的模型效果



参考：[随机森林算法梳理](https://zhuanlan.zhihu.com/p/57965634)

### 1.1.7 GBDT



### 1.1.8 XGBoost



### 1.1.9 lightBGM



## 1.2 回归

- 线性回归
- 岭回归
- 随机森林回归
- 决策树回归
- KNN回归
- 支持向量机回归

## 1.3 分类模型的评价指标

### 1.3.1 阳性阴性

- TP=预测有实际有 TruePositive 真阳
- TN=预测无实际无 TrueNegative 真阴
- FP=预测有实际无 FalsePositive 假阳
- FN=预测无实际有 FalseNegative 假阴

### 1.3.2 评价指标

- Accuracy=(TP+TN)/(TP+TN+FP+FN)=识别对的/识别总数  准确率
- Precision=TP/(TP+FP)=预测有中识别对的/预测有      精确率
- Recall=TP/(TP+FN)=预测有中识别对的/实际有         召回率，结果的完整性
- F1=2\*Recall\*Precision/(Recall+Precision)          以上两者的综合
- AUC=ROC曲线下的面积
- ROC曲线：x轴假阳率(TP/TP+FN)，y轴真阳率(FP/FP+TN)

## 1.4 数据预处理

[How I made top 0.3% on a Kaggle competition](https://www.kaggle.com/lavanyashukla01/how-i-made-top-0-3-on-a-kaggle-competition)

https://zhuanlan.zhihu.com/p/69162289?utm_source=qq&utm_medium=social&utm_oi=1366156478932488192

PPT02讲

### 1.4.1 数据清洗

- 填写缺少的值
- 识别或删除异常值
- 平滑噪声值

### 1.4.2 单变量分析

频数 直方图

删除方差很小的列(都是同一个数值)

### 1.4.3 数据转换

&emsp;&emsp;目的是为了统一量纲。

#### 1.4.3.1 归一化

&emsp;&emsp;将数据变换到某个固定区间中，这个区间通常是[0,1]及[-1,1]等。

- Min-Max归一化：将数据映射到[0,1]之间

$$
X_{new}=\frac{X_{i}-X{min\_old}}{X_{max\_old}-X_{min\_old}}(X_{max\_new}-X_{min\_new})+X_{min\_new}
$$

而X<sub>max_new</sub>和X<sub>min_new</sub>分别是1和0，因此上式可以简化为，
$$
X_{new}=\frac{X_{i}-X_{min}}{X_{max}-X_{min}}
$$

- Mean归一化：将数据映射到[-1,1]之间

$$
X_{new}=\frac{X_{i}-Mean(X)}{X_{max}-X_{min}}
$$

#### 1.4.3.2 标准化

&emsp;&emsp;将数据变换到均值为0，标准差为1的分布，不一定是正态的。

- Z-Score标准化

$$
X_{new}=\frac{X_{i}-Mean(X)}{σ} {\ }{\ }{\ }{\ }σ为标准差
$$

### 1.4.4 数据离散化

&emsp;&emsp;将连续的特征值离散化到多个区间，或将其替换为高级概念(年龄值替换为少年、青年、中年、老年)。因为一些分类算法(如决策树)只接受离散特征，同时离散化能够减小数据量。

- 等宽分桶：离散到N个大小相等的区间，设该特征的最小和最大值分别为A和B，则区间宽度为，

$$
W=\frac{B-A}{N}
$$

异常值会有较大的影响。

- 等深分桶：每个区间内的样本数量大致相同

- 基于熵的离散化

## 1.5 特征选择

&emsp;&emsp;相关性分析：查找最能区分不同类别的特征。

- 皮尔逊相关系数
- 互信息
- 信息增益：计算信息增益，去掉信息增益低于阈值的特征
- 期望交叉熵：用于文本的 
- 距离相关系数
- 递归特征消除RFE
- 随机森林特征选择

&emsp;&emsp;可以综合多种方式对特征集成打分来选择。

## 1.6 模型优化

### 1.6.1 Overfitting(过拟合)

&emsp;&emsp;一些对课本死记硬背的学生将会拥有好成绩，对其他数据集识别就不好(在训练集上准确率非常高，而在测试集上准确率低)。

### 1.6.2 调参

- 参数：根据数据可以自动学习出的变量。比如，深度学习的权重，偏差，回归中的系数等(训练集来调参)
- 超参数：用来确定模型的一些参数，超参数一般就是根据经验确定的变量。超参数不同，模型是不同的。比如，深度学习的学习速率，迭代次数，层数，每层神经元的个数等(验证集来调参)

### 1.6.3 K-Fold交叉验证

先将数据集划分成训练集和测试集，再将训练集划分成K份，每次K-1份训练，1份验证

防止过拟合 https://www.jianshu.com/p/651f998a6398

通过K-Flod多次划分的形式进行训练是为了获取某个模型的性能指标，通过K-Flod记录下较为优异的超参数，然后再以最优模型最优参数进行重新训练，将会取得更优结果

### 1.6.4 遗传算法

&emsp;&emsp;遗传算法可以用于特征选择，或者对已经训练好的模型进行进一步的参数优化。

(1)对特征或者参数进行编码，每个编码代表一个个体，一组个体表示一个种群

(2)对种群中的个体计算适应度

(3)若适应度满足要求，则退出

(4)若不满足，则**选择**适度度较高的个体，作为新种群的父代

(5)对新种群进行**交叉**

(6)对新种群进行**变异**

(7)回到2

## 1.7 集成学习

&emsp;&emsp;集成学习是训练多个个体学习器，通过一定的结合策略，最终形成一个强学习器，结合多个个体的能力，获得远超个体的集体能力优势。要获得好的集成，个体学习器应“好而不同”，即个体学习器要有一定的准确性，并且要有“多样性”，学习器间具有差异。

- 基学习器：所有个体学习器都是同一种类(同质)，比如都使用决策树
- 组件学习器：所有个体学习器不全是同一种类(异质)，比如有的用贝叶斯，有的用逻辑回归
- 弱学习器：泛化性能略优于随机猜测的学习器，例如在二分类问题中精度略高于50%的分类器
- 强学习器：由多个弱学习器结合形成的性能很好的分类器

### 1.7.1 Bagging

&emsp;&emsp;使用Bootstap对原始训练集随机采样，得到T个新训练集，分别独立地训练出T个弱学习器，再对这T个弱学习器通过结合策略来得到最终的强学习器。Bootstap是一种随机采样方法，对于m个样本的原始训练集，我们每次先随机采集一个样本放入采样集，接着把该样本放回，也就是说下次采样时该样本仍有可能被采集到，这样采集 m次，最终可以得到m个样本的采样集，由于是随机采样，这样每次的采样集是和原始训练集不同的，和其他采样集也是不同的，这样最终得到多个不同的弱学习器。

- RandomForest

&emsp;&emsp;RandomForest是对Bagging的一种实现和变体，以决策树为基学习器，不仅对训练集进行随机采样，还对特征进行随机选择。传统决策树在选择划分特征时是在当前结点的特征集合(假定有d个特征)中选择一个最优特征；而在RF中，对基决策树的每个结点，先从该结点的特征集合中随机选择一个包含k个特征的子集，然后再从这个子集中选择一个最优特征用于划分。这里的参数k控制了随机性的引入程度：若令k=d，则基决策树的构建与传统决策树相同；若令k=1，则是随机选择一个特征用于划分；一般情况下，推荐值k=log<sub>2</sub>d。

### 1.7.2 Boosting

&emsp;&emsp;首先从训练集用初始权重训练出一个弱学习器1，根据弱学习的学习误差率表现来更新训练样本的权重，使得之前弱学习器1学习误差率高的训练样本点的权重变高，使得这些误差率高的点在后面的弱学习器2中得到更多的重视。然后基于调整权重后的训练集来训练弱学习器2。如此重复进行，直到弱学习器数达到事先指定的数目T，最终将这T个弱学习器通过结合策略来得到最终的强学习器。

- AdaBoost
- GBDT(Gradient Boosting Decision Tree，梯度提升决策树)
  - XGBoost
  - lightGBM

### 1.7.3 Stacking

&emsp;&emsp;在Bagging和Boosting中，常见的结合策略有平均法和投票法Voting。对于数值类的回归预测问题，通常使用平均法，对于若干个弱学习器的输出进行平均(算术平均、加权平均)得到最终的预测输出。对于分类问题的预测，我们通常使用的是投票法，如少数服从多数。这两种方法都较简单，可能学习误差很大，Stacking是对弱学习器的结果再加上一层学习器，得到最终结果。

&emsp;&emsp;将训练好的所有弱学习器对初始训练集进行预测，第i个训练样本在第j个弱学习器的预测值将作为新的训练集中第i个样本的第j个特征值，即训练集的样本数不变，特征由初始特征值变成了弱学习器的训练结果，最后基于新的训练集进行训练。Stacking 就像是 Bagging的升级版，Bagging中的融合各个基础分类器是相同权重，而Stacking中则不同，Stacking中第二层学习的过程就是为了寻找合适的权重或者合适的组合方式。

&emsp;&emsp;例如，Otto Group Product分类挑战赛的第一名通过对30个模型做stacking赢得了冠军，他将30个模型的输出作为特征，继续在三个模型中训练，这三个模型XGBoost，Neural Network和Adaboost，最后再加权平均，详见文章[Otto Group Product Classification Challenge](https://www.kaggle.com/c/otto-group-product-classification-challenge/discussion/14335)。

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/image-20220104164235304.png" alt="image-20220104164235304" style="zoom:50%;" />

## 1.8 强化学习

马尔科夫链 隐马尔科夫 条件随机场

## 1.9 Python

### 1.9.1 常用数据结构

- List：列表(数组)
- Set：集合(哈希表)
- Dict：字典(键值对)

Python中查找效率：Set≥Dict>List

### 1.9.2 NumPy(矩阵)

创建2行3列的矩阵，用0填充，类型为int

```python
x=np.zeros([2,3],dtype=int)
```

读取文件

```python
np.savetxt(path,x,delimiter=",",fmt='%d')
```

保存文件

```python
y=np.loadtxt(path,delimiter=",")
```

获取第1行第2列的值，索引从0开始

```python
y[1,2]
```

### 1.9.3 Pandas(带标签的矩阵)

&emsp;&emsp;Pandas常用于csv文件的处理，有Series和DataFrame两种，其中csv文件指的是：以逗号来分隔值的文件，在excel文件中打开后就看不到逗号，只看到分割后在各行各列的值。

- Series：带标签(索引)的一维数组，即每个元素都有一个标签，不指定的话就是0 1 2...跟下标一样
- DataFrame：每个Series带一个表头，然后将多个Series并排，类似excel表格

读取文件，第1行作为表头

```python
df.read_csv('文件')
```

查看表头

```python
df.columns
```

 查看表的行数和列数

```python
df.shape    获取大小
df.shape[0] 获取行数 
df.shape[1] 获取列数 
```

查看表的部分数据，默认5行

```python
df.head(n) 查看前n行 
df.tail(n) 查看后n行 
```

iloc根据下标选择数据，前行后列 

```
df.iloc[0,:]     获取第0行 
df.iloc[:,0]     获取第0列 
df.iloc[a:b,c:d] 获取第a~b-1行,第c~d-1列
```

loc根据表头/标签选择数据，前行后列 

```
df.loc[:,['signer_O','signer_L']] 获取指定表头的列
```

直接选择数据，表头如果是1个就返回Series，2个及以上就返回DataFrame

```
df[['signer_O','signer_L']] 获取指定的列
```


### 1.9.4 持久化存储

&emsp;&emsp;joblib和pickle都可以通过dump/load来持久化存储，dump进去的时候是什么数据结构，load出来的时候就是什么，而无需使用for循环一行行读取。joblib对大型NumPy更快，pickle对Dict这类更快。

## 1.10 损失函数

最大似然估计

最小二乘法

梯度下降法

反向传播法

# 2 深度学习(神经网络)

## 2.1 BP(全连接神经网络)

&emsp;&emsp;全连接神经网络是最简单的神经网络，只有输入层、隐藏层、输出层，其中隐藏层的层数根据需要而定。

### 2.1.1 感知机
&emsp;&emsp;感知机通过一些二进制的输入x1，x2，...，代表不的影响决策的因素，然后产生一个二进制的输出：

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/20201201230055461.png" alt="img" style="zoom:67%;" />

&emsp;&emsp;用权重w1，w2...来表示各个输入对输出的重要性。神经元的输出，要么是0要么是1，由权重和w1x1+w2x2+w3x3+...的值是否小于或者大于某一阈值b来确定。感知机网络如下，左侧为输入层；中间为隐藏层,隐藏层的**每一个**感知机都通过权衡第一层的输出结果作为输入，这样以来第二层的感知机可以比第一层做出更加复杂和抽象的决策，更复杂的决策可以在第三层做出；右侧为输出层,输出层的维度为分类的类别个数。

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/20201201232043114.png" alt="img" style="zoom:67%;" />

### 2.1.2 激活层
&emsp;&emsp;一系列线性方程的运算最终都可以用一个线性方程表示，也就是说，多个式子联立后可以用一个线性方程表达。因此就算网络深度加到100层，也依然是这样，这样的话神经网络就失去了意义。因此利用激活函数将结果非线性化,激活函数常用的有3种,分别是阶跃函数、Sigmoid和ReLU,如下

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/20201201233339254.jpg" alt="20201201233339254.jpg (892×294)" style="zoom:67%;" />

&emsp;&emsp;此外，感知机的输入输出也不再限制为0或1，而是0～1之间均可。

### 2.1.3 交叉熵损失loss
&emsp;&emsp;首先要利用Softmax层将输出层的结果正规化（和为1），计算公式如下：

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/20201201235505371.png" alt="20201201235505371.png (124×90)" style="zoom:67%;" />

&emsp;&emsp;最后，我们利用“交叉熵损失”来判断输出的好坏，是对Softmax层结果取对数的负数得到的，

$$
-log()
$$
该值越接近0，说明结果越准确，我们训练神经网络的目的，就是尽可能地减少这个“交叉熵损失”。
### 2.1.4 训练
&emsp;&emsp;梯度下降法(参数优化)：这里的参数指的是权重w和阈值b，假设有参数w1，w2，b1，b2，若增大w1，loss变大了，就减小w1，其他参数以此类推。
&emsp;&emsp;反向传播(链式法则)：在神经网络模型中，由于结构复杂，每次计算梯度的代价很大，因此还需要使用反向传播算法。反向传播算法是利用了神经网络的结构进行的计算，不一次计算所有参数的梯度，而是从后往前：首先计算输出层的梯度，然后是第二个参数矩阵的梯度，接着是中间层的梯度，再然后是第一个参数矩阵的梯度，最后是输入层的梯度。
&emsp;&emsp;训练的过程就是不断微调参数，直到loss我们满意为止。所有训练数据同时输入，走到输出层，计算loss值，反向传播，更新参数，然后进行下一次循环。
&emsp;&emsp;调参指的是调整：隐藏层维度、正则化强度、梯度下降的学习率、循环次数等。

### 2.1.5 一个完整的BP神经网络
&emsp;&emsp;以知乎的[神经网络15分钟入门！使用python从零开始写一个两层神经网络](https://zhuanlan.zhihu.com/p/67682601)坐标系分类为例，

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/2020120212204929.jpg" alt="img" style="zoom: 50%;" />

 - 输入层X为N行2列的矩阵，N为测试组数，2代表横纵2个坐标，如果输入是20×20的图像，那么输入层就是N行400列的矩阵
 - 第一层权重矩阵W1为2行50列，每一列有2个数，分别是与两个坐标相乘的权值，50列代表输出到50个感知机
 - 隐藏层H为：

$$
H=X*W1+B
$$

 再经过激活函数得到：
$$
σ(X*W1+B)
$$


 - 第二层权重矩阵W2为50行4列，每一列有50个数，分别是与隐藏层的50个感知机的输出相乘的权值，4列代表输出到4个感知机，即分类结果有4种（4个象限）



**参考**

- [神经网络和深度学习（一）——初识神经网络](https://blog.csdn.net/qq_31192383/article/details/77145993)
- [神经网络15分钟入门！足够通俗易懂了吧](https://zhuanlan.zhihu.com/p/65472471)
- [神经网络15分钟入门！使用python从零开始写一个两层神经网络](https://zhuanlan.zhihu.com/p/67682601)
- [神经网络浅讲：从神经元到深度学习](https://www.cnblogs.com/subconscious/p/5058741.html)

## 2.2 CNN(卷积神经网络)

&emsp;&emsp;CNN主要用于图像分类，一般包括卷积层、池化层和全连接层。各层之间还有激活函数，一个经典的CNN结构如下。

<img src="C:\Users\Forest\AppData\Roaming\Typora\typora-user-images\image-20211218130126200.png" alt="image-20211218130126200" style="zoom:67%;" />

### 2.2.1 卷积层

&emsp;&emsp;卷积层主要是用卷积核对图像进行扫描，例如一幅4x4的图像，用两个2x2的卷积核Filter1和Filter2扫描，最终得到(4-2+1)\*(4-2+1)\*2即3x3x2的输出，有多少卷积核就输出多少通道。例如对Filter1的输出，左上角的1=1*1+0\*(-1)+1\*1+1\*(-1)。如果是三通道(channel)的彩色图像，也是将三个通道求和，依然得到3x3x2的输出。

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/image-20211218123057206.png" alt="image-20211218123057206" style="zoom: 50%;" />

每一个卷积核都可以被看做特征识别器，可以识别直线、曲线、简单的颜色等等，如下图的卷积核可以识别右边的曲线，

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/image-20211218124314768.png" alt="image-20211218124314768" style="zoom:50%;" />

如果原始图像中有类似的曲线，与该卷积核相乘后，得到的值很大，因为矩阵相同位置都有数值，

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/image-20211218124419119.png" alt="image-20211218124419119" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/image-20211218124539670.png" alt="image-20211218124539670" style="zoom:50%;" />

而如果没有，则得到的数会很小甚至是0，因为数值都与0相乘了，

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/image-20211218124631485.png" alt="image-20211218124631485" style="zoom:50%;" />

可以用多个卷积核识别不同类型的曲线。然后通过增加卷积层，可以识别更高层次的特征，如半圆(曲线和边的组合)或者矩形(四条边的组合)，进一步，爪子、手或耳朵，最后，就能完整地识别手写字、动物等等。

### 2.2.2 池化层

&emsp;&emsp;选出各个卷积区域的最大值、平均值等等。

### 2.2.3 全连接层

&emsp;&emsp;有多少类别就输出几维向量，全连层的工作方式是根据上一层的输出(也就是之前提到的可以用来表示特征的激活图)来决定这张图片有可能属于哪个类别。例如，如果程序需要预测哪些图片是狗，那么全连层在接收到一个包含类似于一个爪子和四条腿的激活图时输出一个很大的值。同样的，如果要预测鸟，那么全连层会对含有翅膀和喙的激活图更感兴趣。基本上，全连层寻找那些最符合特定类别的特征，并且具有相应的权重，来使你可以得到正确的概率。

&emsp;&emsp;CNN的训练方式和BP类似，也是反向传播法。



**参考**

- [零基础理解卷积神经网络](https://zhuanlan.zhihu.com/p/32472241)
- [吴恩达deeplearning之CNN—卷积神经网络入门](https://blog.csdn.net/ice_actor/article/details/78648780)

## 2.3 RNN(循环神经网络)

&emsp;&emsp;参考：[史上最详细循环神经网络讲解（RNN/LSTM/GRU）](https://zhuanlan.zhihu.com/p/123211148)

### 2.3.1 基础版

&emsp;&emsp;RNN对具有序列特性的数据非常有效，它能挖掘数据中的时序信息以及语义信息。关于为什么要发明RNN，以命名体识别为例，有两句话，

```
I like eating apple！(我喜欢吃苹果！)
The Apple is a great company！(苹果真是一家很棒的公司！)
```

在这两句话中，apple的含义是不同的，如果使用BP神经网络，将apple的特征向量送入网络，两句话得到的结果是相同的，因为并没有结合上下文，而RNN就能改善这一点。

&emsp;&emsp;RNN的结构如下，

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/image-20211202113549947.png" alt="image-20211202113549947" style="zoom:50%;" />

如果去掉了W<sub>h</sub>，其架构就与BP神经网络一样，x→W<sub>i</sub>→h→W<sub>o</sub>→y，x是输入层，h是隐藏层，y是输出层，W<sub>u</sub>、W<sub>v</sub>是输入输出的权重矩阵，如果加上W<sub>h</sub>，按照时间线展开，就是，

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/image-20211202113613845.png" alt="image-20211202113613845" style="zoom:67%;" />

x代表的是不同时刻的输入，比如上面的I like eating apple，x<sub>t-1</sub>就是I的特征向量，x<sub>t</sub>是like的特征向量，x<sub>t+1</sub>是eating的特征向量；W<sub>h</sub>是每个时间点之间的权重矩阵，是不变的；RNN之所以可以解决序列问题，是因为它可以记住每一时刻的信息，每一时刻的隐藏层h<sub>t</sub>不仅由该时刻的输入层x<sub>t</sub>决定，还由上一时刻的隐藏层h<sub>t-1</sub>决定，即隐藏层能够记住之前时刻的信息
$$
h_{t}=sigmoid(W_{u}·x_{t}+W_{h}·h_{t-1})
\\
y_{t}=sigmoid(W_{v}·h_{t})
$$
如果我们将输入序列换个顺序，那么我们得到的结果也将是截然不同，这就是RNN的特性，可以处理序列数据，同时对序列也很敏感。RNN的训练方式和BP类似，也是反向传播法。

### 2.3.2 LSTM(长短期记忆网络)

&emsp;&emsp;LSTM是在上面的基础版的基础上改进的，基础版的RNN对于一个很长的句子，到句子末尾时，它将记不住这个句子的开头的内容详细内容([梯度消失和爆炸](https://zhuanlan.zhihu.com/p/76772734))，LSTM通过它的门控装置有效的缓解了这个问题。基础版的RNN没有挑选信息的能力，什么信息都会存下来，而LSTM通过门控装置，可以选择性地存储信息。

&emsp;&emsp;LSTM有一个结构Memory Cell，用于存储每一时刻的信息，类似于基础版中的隐藏层h<sub>t</sub>，其结构如下，

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/image-20211202100408096.png" alt="image-20211202100408096" style="zoom: 50%;" />

共有三个门控制信息流动。

- Input Gate：输入门，在每一时刻从输入层输入的信息会首先经过输入门，输入门的开关会决定这一时刻是否会有信息输入到Memory Cell
- Output Gate：输出门，每一时刻是否有信息从Memory Cell输出取决于这一道门
- Forget Gate：遗忘门，每一时刻Memory Cell里的值都会经历一个是否被遗忘的过程，就是由该门控制的，如果打开，那么将会把Memory Cell里的值清除，也就是遗忘掉

信息传递的顺序是，先经过输入门，看是否有信息输入，再判断遗忘门是否选择遗忘Memory Cell里的信息，最后再经过输出门，判断是否将这一时刻的信息进行输出。

&emsp;&emsp;在LSTM中，有两个传递状态，一是c<sub>t</sub>，即上面的MemoryCell，二是隐藏层状态h<sub>t</sub>，

<img src="https://raw.githubusercontent.com/Forest216/cloud-image/main/image-20211202105232106.png" alt="image-20211202105232106" style="zoom:67%;" />

图中⊙代表矩阵点乘(对应元素相乘)，⊕代表矩阵相加。z<sub>i</sub>、z<sub>o</sub>、z<sub>f</sub>这三个门控信号是由当前输入x<sub>t</sub>和上一个状态传下来的h<sub>t-1</sub>拼接后，再与对应的权重矩阵W点乘，再经过激活函数得到的，
$$
z_{i}=sigmoid(W_{i}·[x_{t},h_{t-1}])
\\
z_{o}=sigmoid(W_{o}·[x_{t},h_{t-1}])
\\
z_{f}=sigmoid(W_{f}·[x_{t},h_{t-1}])
$$
经过激活函数sigmoid后，z<sub>i</sub>、z<sub>o</sub>、z<sub>f</sub>都是0到1之间的数值，0表示该门完全关闭，1表示该门完全打开，门控信号越接近1，代表记忆下来的数据越多，而越接近0则代表遗忘的越多。z<sub>i</sub>、z<sub>o</sub>、z<sub>f</sub>分别代表上边的输入、输出、遗忘三个门。z代表的是输入数据，是用tanh来激活的，值转换到-1~1，不用sigmoid的原因是要将其作为输入数据，而不是门控信号。
$$
z=tanh(W_{u}·[x_{t},h_{t-1}])
$$
这里的Wu和图中yt计算用的W'其实类似于基础版中的Wu和Wv，而上面sigmoid公式中的三个W是新的权重矩阵。

### 2.3.3 GRU

&emsp;&emsp;GRU的结构与基础版的RNN类似，与LSTM相比，效果相当，而结构更简单(少了一个门)，计算效率更高，所需资源也少。GRU有两个门控信号，z<sub>r</sub>(重置)和z<sub>u</sub>(更新)，
$$
z_{r}=sigmoid(W_{r}·[x_{t},h_{t-1}])
\\
z_{u}=sigmoid(W_{u}·[x_{t},h_{t-1}])
$$
首先用重置信号对上一个隐藏层状态h<sub>t-1</sub>进行重置，
$$
h_{t-1}'=h_{t-1}⊙z_{r}
$$
然后用新的ht-1'计算输入，
$$
z=tanh(W_{u}·[x_{t},h_{t-1}'])
$$
接下来进行更新，
$$
h_{t}=(1-z_{u})⊙h_{t-1}+z_{u}⊙z
$$
门控信号z<sub>u</sub>的范围为0~1，越接近1，代表记忆下来的数据越多，而越接近0则代表遗忘的越多，**GRU用一个门控信号z<sub>u</sub>就可以同时进行遗忘和记忆(而LSTM需要多个门控)**。

- (1-z<sub>u</sub>)⊙h<sub>t-1</sub>表示对原之前隐藏状态的选择性遗忘，这里的1-z<sub>u</sub>可以想象成LSTM的遗忘门，忘记h<sub>t-1</sub>维度中一些不重要的信息
- z<sub>u</sub>⊙z表示对输入进行选择性记忆

综上所述，这一步的操作就是忘记传递下来的h<sub>t-1</sub>中的某些维度信息，并加入当前节点输入的某些维度信息。这里的遗忘1-z<sub>u</sub>和选择z<sub>u</sub>是联动的，也就是说，对于传递进来的维度信息，我们会进行选择性遗忘，则遗忘了多少权重1-z<sub>u</sub>，我们就会使用包含当前输入的z中所对应的权重z<sub>u</sub>进行弥补，以保持一种恒定状态。

最终的输出同前面的一样，为
$$
y_{t}=sigmoid(W_{v}·h_{t})
$$

## 2.4 GAN(生成对抗网络)



## 2.5 Transformer







