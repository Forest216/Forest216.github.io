# 1 准备

## 1.1 经验

### 1.1.1 自己

- 投递简历需谨慎，有的会锁简历，绝大多数会有面评记录，不要轻信提前批不影响正式批
- 认真准备，争取更高的评级，这对未来升职很重要，实习转正答辩会有评分评级，秋招更会有评级

### 1.1.2 面试官/宣讲会

- 对实习，重点是项目的上游(需求)下游，数据是怎么串起来的，而不是怎么实现的(微软)
- 面试不是考试，**很看重沟通**(以后工作怎么沟通)，面试官主观性，对方愿不愿意和你一起工作(微软)
- 算法题目的思维过程，遇到挑战时的态度和应对，会不会与面试官沟通(微软)
- 团队合作，成长潜力，对工作的热情和复制(微软)
- 简历中包含求职意向(微软)
- 计算机基础是重点(字节)
  - 打好基础：参考计算机培养方案
  - 有所专精：在某个领域能深挖进去
  - 开阔视野：关注前沿趋势
- 

### 1.1.3 学长学姐

- 外企 字节 腾讯重视算法，阿里 美团重视工程
- 面试之前先刷几篇面经，找找感觉
- 前期可以多投小公司熟悉流程、积累经验
- 面试中，学会引导面试官
- 关注业务是做什么的，关系着未来的成长空间
- 简历不要罗列名词，突出自己用提到的技术名词做了什么
- 注意编码规范，面试官会在意(面TrendMicro的时候就是这样)
- 投简历不要太晚，防止没有HC
- 算法岗有研究和业务两个方向

## 1.2 MicroSoft

- 自我介绍+项目+**算法**
- 面试绝大多数是中文，可以准备下英文的自我结束和项目介绍
- 不要用edu邮箱，可能会被拦截

### ~~1.2.1 微软暑期实习提前批~~

- 1.03投递截止
- 1.17~1.21面试
- 两轮平行面(过一个就行)+一轮leader面
- 如果挂了正式批基本没机会了

### 1.2.2 微软暑期实习正式批

- 笔试+两轮平行面(过一个就行)+一轮leader面
- **笔试/问卷：2.11/2.25**
- **内推免笔试**(最好找个内推，公众号下有内推，内推也快)
- **2.21**开始面试
- 职位介绍和投递经验：https://docs.qq.com/doc/DV0NGWmVhVGFPR1dz
- 亚太研发
  - STCA亚洲互联网工程院：北京/苏州，大数据开发
  - C+AI云计算与人工智能：北京/上海，数据开发
  - CMD(Cloud Management Desktop)：苏州
  - MSRA微软亚洲研究院(MicroSoft Research Aisa)：北京/上海

### 1.2.3 MSRA明日之星

- 独立于上面两个微软的实习项目



## 1.3 Google

### 1.3.1 暑期实习生

- (已投)SWE软件工程实习生
- Google Cloud客户工程师实习生**(3.10截止)**
- 上海/北京
- 两轮，均为电话面试，45分钟
- 简历经历、编程、**算法**、数据结构。
- 面试流程介绍：https://careers.google.cn/how-we-hire/interview/
- 经验：https://mp.weixin.qq.com/s/P6hk8wr0StHXyGhqVLv1qQ

### 1.3.2 Kick Start

- Kick Start：算法，每年8轮，2.02开始，3小时
- Hash Code：工程，2.24资格赛，**2.22截止报名**，4小时，2~4人

- 经验：https://mp.weixin.qq.com/s/c0Vx1qUFhesf5-bPNAWmww

### 1.3.3 Google Cloud 成长计划

3~6月份，10周，线上项目



## 1.4 ByteDance

- AI Lab
- Data
- 产品研发(有一个方向是信息安全风控，及时发现黑产、引流等)



字节会看之前的面评，谨慎投递

## 1.5 Alibaba

- 阿里的提前批似乎不怎么影响正式


## 1.6 Tencent

- 腾讯大部分HC在提前批
- 

## 1.7 Baidu



## 1.8 华为



## 1.9 美团



## 1.10 京东



## 1.11 拼多多



## 1.12 网易



## 1.13 Bilibili



## 1.14 外企 

- Shopee
- Amazon
- Intel
- IBM
- Zoom
- SAP

## 1.15 金融

- 华泰证券
- (已投)上海银行总行
- (已投)上海证券交易所
- 量化私募

## 1.16 手机

- 小米
- oppo
- vivo

## 1.17 其他

- 米哈游
- 顺丰
- 小红书
- 知乎
- 携程
- 贝壳

# 2 问过的问题

## 2.1 已投

- 谷歌暑期实习
  - 软件工程实习生
- 上海银行总行
  - 数据分析岗+软件开发岗
- 上海证券交易所
  - 信息科技类

## 2.2 TrendMicro

- 项目

协方差矩阵怎么求

高光谱那里进行的优化

建模

- Java

Array ArrayList区别：Array指的是普通的数组

Double double

泛型

- Android

安卓四大组件

layout

chart

- 算法

手写二叉树遍历

- 其他

简历上的个人网站打不开，可能的原因有哪些，如何找原因

看了Python写过的程序，并进行了代码讲解

## 2.3 途牛

- 项目

建模

- Java

Java集合

- SQL

join

sort

like

union

大表小表

- Hadoop

HDFS副本存放策略

对Hive的了解，他们用Hive最多

- 其他

Python写过的程序

机器学习的算法知道哪些

# 3 Java

- 编译型语言：通过编译器将源代码一次性翻译成可被该平台执行的机器码，执行速度比较快，开发效率比较低，移植到其他操作系统上要重新编译，常见的有C、C++、Go等
- 解释型语言：通过解释器一句一句地将代码解释为机器码后再执行，即边解释边执行，开发效率比较快，执行速度比较慢常见的有Python、JavaScript等

&emsp;&emsp;Java比较特殊，先编译后解释。编译器javac将源代码编译成与操作系统无关的字节码(.class文件)，虚拟机JVM将字节码文件解释执行。不同操作系统有不同的JVM，而这些JVM向javac提供相同的编程接口，javac只需要面向JVM生成字节码，这就保证了Java的跨平台性，即编译一次之后，就可以在不同操作系统上解释执行了。

<img src="C:\Users\Forest\AppData\Roaming\Typora\typora-user-images\image-20220122110910267.png" alt="image-20220122110910267" style="zoom:50%;" />

- JVM：运行Java字节码(.class)的虚拟机
- JRE：运行环境，包括虚拟机JVM、Java类库等等
- JDK：开发环境，包括JRE、编译器javac等等，能够创建和编译程序

## 3.1 面向对象

### 3.1.1 类和实例

#### 3.1.1.1 static

- 类变量(静态变量)：static修饰，变量是属于类的，**类所有的实例都共享静态变量**，在内存中只存在一份，可以直接通过类名来访问
- 实例变量：每创建一个实例就会产生一组实例变量，它们与该实例同生共死，通过实例的引用变量访问，在实例内部通过this或super访问

- 类方法访问类变量

```java
public class Animal {
    public static String name;
    public static String getName(){
    	return Animal.name; //Animal可省略
    }
}
```

- 类方法访问实例变量，类方法中不能有this或super，**只能重新创建一个新实例**，因为类方法是属于类的，调用者是一个类，而不是实例，this或super也就失去了意义

```java
public class Animal {
    public String name;
    public static String getName(){
        return new Animal().name;
    }
}
```

- 实例方法访问实例变量

```java
public class Animal {
    public String name; 
    public String getName(){
    	return this.name; //this可省
    }
}
```

- 实例方法访问类变量，类所有的实例都共享静态变量

```java
public class Animal {
    public static String name; 
    public String getName(){
    	return Animal.name; //不建议省Animal
    }
}
```

#### 3.1.1.2 变量

&emsp;&emsp;根据定义变量位置的不同，可以将变量分为成员变量和局部变量，成员变量即类变量和实例变量(定义在类里的变量)，局部变量为在方法中定义的变量，包括形参、方法局部变量(在一个方法体内定义，作用域是从定义该变量的位置到该方法结束)、代码块局部变量(在代码块中定义，作用域是从定义该变量的位置到该代码块结束)。

&emsp;&emsp;当系统加载类或创建类的实例时，会自动为成员变量分配内存空间，并在分配内存空间后，自动为成员变量指定初始值；而系统不会为除形参以外的局部变量分配内存空间和执行初始化，直到程序为这个变量赋初始值时，系统才会为局部变量分配内存，并将初始值保存到这块内存中；当通过类或实例调用某个方法时，系统会在该方法栈区内为该方法的所有形参分配内存空间，并将实参的值赋给对应的形参，这就完成了形参的初始化。

&emsp;&emsp;成员变量储存在堆内存中，通过栈内存中的引用变量来引用，局部变量总是保存在其所在方法的栈内存中。如下代码共产生了一个引用变量a和Person实例(包含它的成员变量和方法)，Person实例存放在堆内存中，引用变量a存放在栈内存中，**存储地址值**，指向实际的Person实例。

```java
Person a; //声明一个引用类型Person的变量a
a = new Person(); //通过new关键字调用Person类的构造器，返回一个Person实例，然后将该实例赋给a变量

Person a = new Person(); //以上两行代码可简写为这一行
```

&emsp;&emsp;对于Java来说，并不存在引用传递，而是采用按值传递，函数得到的是参数的拷贝，不能修改传递给它的参数变量的内容，当传递一个引用变量时，也是拷贝了引用变量，两个引用变量指向同一个实例，会修改实例的数据。

#### 3.1.1.3 final



### 3.1.2 继承extends

#### 3.1.2.1 访问权限



第一行是调用父类构造器



第一次构建时调用(类加载)



方法重写：子类重写父类的方法，参数列表相同，返回类型是父类的派生类，访问权限要比父类高
方法重载：同一类中的同名方法，参数列表不同，返回类型可同可不同，常用于构造器重载



子类是不继承父类的static变量和方法的。因为这是属于类本身的。但是子类是可以访问的。 
子类和父类中同名的static变量和方法都是相互独立的，并不存在任何的重写的关系。
如果继承的是父类的方法(没有重写)，父类的方法调用父类的变量

初始化顺序为：

- 父类（静态变量、静态语句块）
- 子类（静态变量、静态语句块）
- 父类（实例变量、普通语句块）
- 父类（构造函数）
- 子类（实例变量、普通语句块）
- 子类（构造函数）

### 3.1.3 多态

向上自动转型：父类引用变量指向子类对象，属于自动类型转换

向下强制转型



父类引用指向子类对象，调用方法时会调用子类的实现，指向不同子类时，调用的方法不同，这就是多态
编译时类型：父类
运行时类型：子类
应用：当创建多个不同的子类对象,而又想统一处理这批对象时,就可以使用多态数组；
有的方法内部需要用到另外的类的对象,但是在设计方法时,又不需要关心究竟是哪个对象,只关心这些实参对象都是某个类型的,此时,方法的参数的类型就可以写成父类类型的参数

### 3.1.4 接口



### 3.1.5 抽象类



## 3.2 基础

&emsp;&emsp;java.lang提供了一些基础类，无需import，由编译器自动引入。包含Object类、包装类、Math类、Runtime类、字符串类、异常处理类、线程类等。java.util提供了一些功能类，包括Date类、Random类、容器类等。

### 3.2.1 基础类型

- byte/8 bit
- char/16 bit
- short/16 bit
- int/32 bit   -2<sup>31</sup>~2<sup>31</sup>-1   2<sup>31</sup>≈2*10<sup>9</sup>
- float/32 bit
- long/64 bit
- double/64 bit
- boolean/JVM 会在编译时期将boolean类型的数据转换为int，使用1来表示true，0表示false

### 3.2.2 包装类型

&emsp;&emsp;每个基本类型都有对应的包装类型，包装类的好处有，ArrayList这些容器只能使用引用类型，这就要用到包装类。

- Byte
- Character
- Short
- Integer
- Float
- Long
- Double
- Boolean

```java
Integer x=new Integer(10);
```

#### 3.2.2.1 自动装箱和拆箱

&emsp;&emsp;在老版本中，创建包装类要用上面的方式，而现在只需要用如下方式，装箱是指自动根据数值创建对应的包装类对象，拆箱是自动将包装类型转换为基本数据类型。

```java
Integer x = 2; //装箱 调用了Integer.valueOf(2)
int y = x;     //拆箱 调用了X.intValue()
```

#### 3.2.2.2 缓存池

&emsp;&emsp;new Integer(123)与Integer.valueOf(123) 的区别在于：new Integer(123)每次都会新建一个对象；Integer.valueOf(123)会使用缓存池中的对象，多次调用会取得同一个对象的引用。

```java
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y); //false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k); //true
```

Integer缓存池的大小默认为-128~127，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象，否则要创建新对象。

### 3.2.3 String

#### 3.2.3.1 常用函数

```java
String test="HelloWorld";
```

- length()，字符串长度

```java
test.length()
```

- charAt，根据索引返回字符

```java
char c=test.charAt(1); //e
```

- indexOf，返回指定字符/子串在字符串中第一次出现处的索引，如果没有则为-1

```java
int index=test.indexOf('e'); //1
int index=test.indexOf("ll"); //2
```

- substring，返回子串，substring(n)表示[n,结尾]，substring(a,b)代表[a,b)

```java
String string1=test.substring(1); //"elloWorld"
String string1=test.substring(1,3); //"elloWorld"
```

- replaceAll，替换，前面是正则表达式，后面是新串

```java
String string=test.replaceAll("ll","22"); //"He22oWorld"
```

- split，切分，返回String[]

```java
String test="025-123456";
String[] string=test.split("-"); //string[0]="025" string[1]="123456"
```

- Integer.parseInt，String转int

```java
String test="1";
int num=Integer.parseInt(test); //025
```

- int转String

```java
String test=String.valueOf(123);
```

#### 3.2.3.2 String Pool

&emsp;&emsp;String内部被声明为final的byte[]，是不可变的。创建字符串常量时，JVM会检查**String Pool(字符串常量池)**中是否存在这个字符串，若存在，则直接返回引用实例；若不存在，先实例化该字符串，并将该字符串放入String Pool中，以便于下次使用时直接取用。

&emsp;&emsp;采用"123"这种形式创建字符串，会自动地将字符串放入String Pool中；而new String("123")这种形式会在堆中创建一个String对象，并指向String Pool。intern()用于直接指向String Pool中的对象。

<img src="C:\Users\Forest\AppData\Roaming\Typora\typora-user-images\image-20220118093553327.png" alt="image-20220118093553327" style="zoom: 50%;" />

```java
String str1 = "123";
String str2 = "123";
String str3 = "123";
String str4 = new String("123");
String str5 = new String("123");
String str6 = new String("123");
String str7 = str6.intern();

str1 == str2: true
str2 == str3: true
str3 == str4: false
str4 == str5: false
str5 == str6: false
str6 == str7: false
str1 == str7: true
    
String str1 = "ab";
String str2 = "cd";
"ab" + "cd"; //池:"abcd"
str1 + str2; //池:"ab" "cd" "abcd"
new String("ab" + "cd"); //池:"ab" "cd" "abcd" 堆:new String("abcd")
new String("ab") + new String("ab"); //池:"ab" 堆:new String("ab") new String("ab")
new String("ab") + new String("cd"); //池:"ab" "cd" 堆:new String("ab") new String("cd")
new String("ab") + "ab"; //池:"ab" 堆:new String("ab")
```

#### 3.2.3.3 StringBuilder 

&emsp;&emsp;String是不可变的，StringBuilder是可变的，修改时对对象本身进行操作，而不是生成新的对象。但StringBuilder不是线程安全的，单线程StringBuilder效率更高。

```java
StringBuilder str=new StringBuilder();//创建初始容量默认为16的StringBuilder
StringBuilder str=new StringBuilder(10);//创建初始容量默认为参数的StringBuilder
StringBuilder str=new StringBuilder("helloworld");//创建初始容量为参数串长度+16的StringBuilder
```

- length()返回的是里面字符串的长度而不是总容量
- append，将串追加，若容量不足则扩为原容量*2+2

```java
str.append("abc");
```

- delete，删除子串，包括start，不包括end

```java
str.delete(8,10); //helloworabc
```

- insert，插入子串

```java
test.insert(8,"ld"); //helloworldabc
```

- 其他函数跟String类型

#### 3.2.3.4 StringBuffer

&emsp;&emsp;StringBuffer也是可变的，并且是线程安全的，内部使用synchronized进行同步，多线程要用StringBuffer。String由于不可变本身就是线程安全的。

```java
StringBuffer str=new StringBuffer();//同StringBuilder
```

### 3.2.4 Object

&emsp;&emsp;Object类是所有类的父类，任何一个类的定义的时候如果没有明确的继承一个父类的话，那么它就是Object的子类，Object类的构造方法有一个，并且是无参构造。Object类主要有如下几种方法。

- equals()，`==`判断2个变量是否引用同一个对象，`equals()`判断2个变量所引用对象的值是否相同

```java
Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x == y); // false
System.out.println(x.equals(y)); // true
```

- hashCode()，返回哈希值
- toString()，默认返回`包名.类名@哈希值16进制`，一般进行重写，String重写为了返回字符串本身

### 3.2.5 泛型



### 3.2.6 反射



### 3.2.7 异常



## 3.3 容器

&emsp;&emsp;容器主要包括Collection和Map两种，注意Collection、SetList、Queue、Deque、Map都是接口，所以不能直接new。用的比较多的：**ArrayList、LinkedList、HashMap**。

<img src="C:\Users\Forest\AppData\Roaming\Typora\typora-user-images\image-20220120090836148.png" alt="image-20220120090836148" style="zoom: 67%;" />

<img src="C:\Users\Forest\AppData\Roaming\Typora\typora-user-images\image-20220120091142859.png" alt="image-20220120091142859" style="zoom: 67%;" />

**Collection**

- add(E e)，添加元素
- remove(Object o)，删除指定元素
- contains(Object o)，是否包含某元素
- size()，大小
- isEmpty()，是否为空
- iterator()，返回迭代器，for each会自动转为迭代器

```java
Iterator<String> it = list.iterator();
while(it.hashNext()){
    String s=it.next();
    System.out.pintln(s);
}

for (String s : list) {
    System.out.println(s);
}
```

- sort()，排序

```java
ArrayList<Integer> list=new ArrayList<Integer>();
Collections.sort(list);
```

对于普通的数组，使用java.util.Arrays的sort()进行排序

```java
int[] array=new int[5];
Arrays.sort(array);
```

### 3.3.1 List(列表)

**List**

- add(E e)，add(int index, E e)，添加元素
- remove(int index)，删除元素
- get(int index)，获取元素
- set(int index, E e)，更新元素
- indexOf(Object o)，某元素的索引，不存在则返回-1

#### 3.3.1.1 ArrayList

&emsp;&emsp;底层使用数组实现的，支持随机访问，默认大小为10，与普通数组相比，能够动态扩容。当容量不足时，容量扩为原来的1.5倍，先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，因此扩容的代价很高，最好在创建时就指定大概的容量大小，减少扩容操作的次数。此外删除、插入跟普通数组一样，代价很高。

```java
ArrayList<Integer> list=new ArrayList<Integer>(); //创建默认为10的列表
ArrayList<Integer> list=new ArrayList<Integer>(100); //创建大小为100的列表
```

#### 3.3.1.2 LinkedList

&emsp;&emsp;基于双向链表实现，可用作栈、队列、双向队列，插入删除效率高，但不支持随机访问且更占空间，ArrayList和LinkedList的区别相当于数组和链表的区别。

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;
}
```

LinkedList实现了Deque接口，addLast和removeLast结合使用可作为栈，addLast和removeFirst结合可用作队列。

#### ~~3.3.1.3 Vector~~

&emsp;&emsp;实现与 ArrayList 类似，但是使用了synchronized进行同步，是线程安全的，但效率更低，一般不使用Vector，而是程序员自己控制ArrayList的同步。

#### ~~3.3.1.4 Stack~~

&emsp;&emsp;Stack继承了Vector类，由于底层是数组，效率较低，因此更多地使用LinkedList作为栈。

### 3.3.2 Set(集合)

&emsp;&emsp;Set用于存储不重复元素，一般用来查找某个元素是否存在。

- TreeSet：基于红黑树实现，支持有序性操作，查找效率为O(logn)。
- HashSet：基于HashMap实现，无序的，查找效率为O(1)。
- LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序

### 3.3.3 Queue(队列)

- PriorityQueue：优先队列，基于堆结构实现

**Queue**

- offer(E e)，在队尾插入元素
- poll()，返回队头并删除，队列为空返回null
- peek()，返回队头但不删除，队列为空返回null

**Deque**

&emsp;&emsp;Double Ended Queue，双向队列，队列两头都可以进出(Queue只能一头进，另一头出)，

- addFirst，在队头添加
- addLast，在队尾添加
- removeFirst，删除队头并返回
- removeLast，删除队尾并返回
- getFirst，获取队头元素，不删除
- getLast，获取队尾元素，不删除

### 3.3.4 Map(键值对)

&emsp;&emsp;Key不能重复；要能够快速地通过Key找到Value，即查找Key的效率要高。

**Map**

- size()，大小
- isEmpty()，是否为空
- containsKey(Object key)，是否包含某Key
- containsValue(Object value)，是否包含某Value
- put(K key, V value)，添加新的键值对
- get(Object key)，获取某Key对应的Value，若不存在该Key，则返回null
- remove(Object key)，删除某Key对应的键值对
- keySet()，获取Key的Set
- values()，获取Value的Set
- entrySet()，获取键值对的Set

#### 3.3.4.1 TreeMap

&emsp;&emsp;基于红黑树实现。

#### 3.3.4.2 HashMap

&emsp;&emsp;用数组作为哈希表，计算Key的hashCode()，对数组长度取模后作为数组下标，数组存Value，这样对一个Key，能马上找到其Value。对于哈希值来说，相同Key的哈希值一定相同，不同的Key哈希值小概率相同(哈希碰撞)，相同时用链表存储，当链表长度≥8时，链表转为红黑树，由于在链表/红黑树中查找效率会降低，因此写的hashCode()要尽可能的好，或者哈希表的长度尽可能的长。

<img src="C:\Users\Forest\AppData\Roaming\Typora\typora-user-images\image-20220120105902379.png" alt="image-20220120105902379" style="zoom:50%;" />

数组默认长度为16，hashCode%16得到数组下标，如115%16=3，当哈希值相同时，后插入的元素是先被查找到的。而取模可以用效率更高的位运算代替，115&15=3。当容量不足时，会将数组容量扩为原来的2倍，需要重新计算下标，容量需为2<sup>n</sup>，可以利用这一点快速计算新下标。频繁扩容对HashMap的性能影响很大，初始化时最好确定其大小。

```java
HashMap<String,Integer> map=new HashMap<>(10000); //实际数组长度初始化为比10000大的16384 2^14
```

- put(K key, V value)，会覆盖旧Value，注意这里是相同Key的多个Value，而不是不同Key的哈希值相同
- getOrDefault(K key, V value)，获取指定Key对应的Value，若不存在该Key，则返回设置的Value

#### ~~3.3.4.3 HashTable~~

&emsp;&emsp;和HashMap类似，但它是线程安全的，这意味着同一时刻多个线程同时写入HashTable不会导致数据不一致。它是遗留类，不应该去使用它，而是使用ConcurrentHashMap来支持线程安全，ConcurrentHashMap的效率会更高，因为ConcurrentHashMap引入了分段锁。

#### 3.3.4.4 LinkedHashMap

&emsp;&emsp;使用双向链表来维护元素的顺序，顺序为插入顺序，或者最近最少使用(LRU)顺序。



Array

Collections

sort 

## 3.4 I/O



## 3.5 多线程和锁机制



## 3.6 JVM



## 3.7 JavaWeb

### 3.7.1 MVC架构

#### 3.7.1.1 Servlet

&emsp;&emsp;要自己实现HTTP服务器，需先编写基于多线程的TCP服务，然后在一个TCP连接中读取HTTP请求，发送HTTP响应，需要考虑线程、复用等等问题，基础工作太复杂，而Servlet可以实现这些功能，Servlet可以运行在Web服务器上，如Tomcat。一个Web App就是由一个或多个Servlet组成的，每个Servlet通过注解说明自己能处理的路径，如"/hello"。

#### 3.7.1.2 JSP

&emsp;&emsp;Java Server Pages，使用Servlet发送HTTP响应时需要使用PrintWriter一行行输出，很麻烦，JSP与HTML类似，区别在于可以插入Java代码。本质上，JSP在执行前首先被编译成一个Servlet。JSP有一些替代的模板引擎，如Thymeleaf，对页面开发更加友好。

#### 3.7.1.3 MVC

- Servlet适合编写Java代码，实现各种复杂的业务逻辑，但不适合输出复杂的HTML
- JSP适合编写HTML，并在其中插入动态内容，但不适合编写复杂的Java代码

&emsp;&emsp;可以将两者结合起来，JavaBean+JSP+Servlet，例如我们有几个JavaBean，

```java
public class User {
    public long id;
    public String name;
    public School school;
}

public class School {
    public String name;
    public String address;
}
```

在UserServlet中，我们可以从数据库读取User、School等信息，然后，把读取到的JavaBean传给User.jsp处理，在User.jsp中，我们只负责展示相关JavaBean的信息，不需要编写访问数据库等复杂逻辑。

&emsp;&emsp;我们把UserServlet看作业务逻辑处理，把User看作模型，把User.jsp看作渲染，这种设计模式通常被称为MVC(Model-View-Controller)，即UserServlet作为控制器(Controller)，User作为模型(Model)，User.jsp作为视图(View)。使用MVC模式的好处是，Controller专注于业务处理，它的处理结果就是Model。Model可以是一个JavaBean，也可以是一个包含多个对象的Map，Controller只负责把Model传递给View，View只负责把Model给“渲染”出来，这样，三者职责明确，且开发更简单，因为开发Controller时无需关注页面，开发View时无需关心如何创建Model。

### 3.7.2 IoC

&emsp;&emsp;在传统的应用程序中，一些组件是如下运作的，一个在线书店，通过BookService获取书籍，为了从数据库查询书籍，BookService持有一个DataSource，为了实例化一个DataSource，又需要实例化一个HikariConfig，

```java
public class BookService {
    private HikariConfig config = new HikariConfig();
    private DataSource dataSource = new HikariDataSource(config);

    public Book getBook(long bookId) {
        try (Connection conn = dataSource.getConnection()) {
            ...
            return book;
        }
    }
}
```

通过UserService获取用户，UserService也需要访问数据库，因此也需要实例化DataSource和HikariConfig，

```java
public class UserService {
    private HikariConfig config = new HikariConfig();
    private DataSource dataSource = new HikariDataSource(config);

    public User getUser(long userId) {
        try (Connection conn = dataSource.getConnection()) {
            ...
            return user;
        }
    }
}
```

在处理用户购买的CartServlet中，我们需要实例化UserService和BookService，在购买历史HistoryServlet中，也需要实例化UserService和BookService。

&emsp;&emsp;这种方式会有很多问题，

- 实例化一个组件较复杂，还要读取配置，并可能先实例化其他组件
- BookService和UserService完全可以共享同一个DataSource，CartServlet和HistoryServlet也可以共享BookService实例和UserService实例，但谁负责创建不好确定
- 很多组件需要销毁以便释放资源，例如DataSource，但如果该组件被多个组件共享，如何确保它的使用方都已经全部被销毁，即如何确定销毁的顺序

&emsp;&emsp;传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制。IoC(Inversion of Control，**控制反转**)中，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序可以直接使用已经创建好并且配置好的组件。IoC是通过**依赖注入**实现的。IoC的实现如下，

```java
public class BookService {
    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
```

BookService自己并不会创建DataSource，而是等待外部通过setDataSource()方法来**注入**一个DataSource，这样做的好处如下，

- BookService不再关心如何创建DataSource，因此，不必编写读取数据库配置之类的代码
- DataSource实例被注入到BookService，同样也可以注入到UserService，因此，共享一个组件非常简单

可以通过XML文件来告诉容器如何创建组件，以及各组件的依赖关系，

```xml
<beans>
    <bean id="dataSource" class="HikariDataSource" />
    <bean id="bookService" class="BookService">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <bean id="userService" class="UserService">
        <property name="dataSource" ref="dataSource" />
    </bean>
</beans>
```

该配置文件相当于如下Java代码，

```java
DataSource dataSource = new HikariDataSource();
BookService bookService = new BookService();
bookService.setDataService(dataService);
UserService userService = new UserService();
userService.setDataService(dataService);
```

如果注入的不是Bean，而是boolean、int、String这样的数据类型，则通过value注入，例如，创建一个HikariDataSource，

```xml
<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource">
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test" />
    <property name="username" value="root" />
    <property name="password" value="password" />
    <property name="maximumPoolSize" value="10" />
    <property name="autoCommit" value="true" />
</bean>
```

最后，我们需要创建一个Spring的IoC容器实例，然后加载配置文件，让Spring容器为我们创建并装配好配置文件中指定的所有Bean，

```java
ApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
```

接下来，我们就可以从Spring容器中取出装配好的Bean然后使用它，

```java
UserService userService = context.getBean(UserService.class); //获取Bean
User user = userService.login("bob@example.com", "password"); //使用
```

&emsp;&emsp;使用XML配置的优点是所有的Bean都能一目了然地列出来，入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。可以使用Annotation配置，利用注解，让Spring自动扫描Bean并组装它们。

&emsp;&emsp;**@Component**注解就相当于定义了一个Bean，

```java
@Component
public class MailService {
    ...
}
```

使用**@Autowired**注解就相当于把指定类型的Bean注入到指定的字段中，

```java
@Component
public class UserService {
    @Autowired
    MailService mailService;
    ...
}
```

加载配置文件使用如下，同时配置类需要使用**@Configuration**注解和**@ComponentScan**注解，后者用于告诉容器，自动搜索当前类所在的包以及子包，把所有标注为@Component的Bean自动创建出来，并根据@Autowired进行装配。

```java
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
```

&emsp;&emsp;对于Spring容器来说，当我们把一个Bean标记为@Component后，它就会自动为我们创建一个单例，即容器初始化时创建Bean，容器关闭前销毁Bean，在容器运行期间，我们调用getBean(Class)获取到的Bean总是同一个实例。

### 3.7.3 AOP

&emsp;&emsp;Aspect Oriented Programming，面向切面编程。在BookService中有多个业务方法createBook、updateBook、deleteBook，对每个业务方法，除了业务逻辑，还需要安全检查、日志记录和事务处理，后者会重复出现在每个业务方法中，而在BookService中我们需要关心的应该是自身的核心逻辑。使用AOP，我们可以把安全检查等看作一种切面(Aspect)，然后利用JVM的动态代理功能将Aspect自动化地织入到BookService中。

<img src="C:\Users\Forest\AppData\Roaming\Typora\typora-user-images\image-20211227121434391.png" alt="image-20211227121434391" style="zoom:47%;" />

<img src="C:\Users\Forest\AppData\Roaming\Typora\typora-user-images\image-20211227121457774.png" alt="image-20211227121457774" style="zoom:50%;" />

<img src="C:\Users\Forest\AppData\Roaming\Typora\typora-user-images\image-20211227121545498.png" alt="image-20211227121545498" style="zoom:51%;" />

&emsp;&emsp;例如，我们要加入日志记录的Aspect，首先定义一个LoggingAspect，**@Before**注解及public指的是在执行UserService的每个public方法前执行doAccessCheck()代码，**@After**则是方法后，**@Around** 指在目标方法执行中执行，可控制目标方法是否执行，环绕通知。该类还要加入**@Aspect**注解和**@Component**注解，后者表示该Aspect是一个Bean，用于IoC注入。

```java
@Aspect
@Component
public class LoggingAspect {
    // 在执行UserService的每个方法前执行:
    @Before("execution(public * com.itranswarp.learnjava.service.UserService.*(..))")
    public void doAccessCheck() {
        System.err.println("[Before] do access check...");
    }

    // 在执行MailService的每个方法前后执行:
    @Around("execution(public * com.itranswarp.learnjava.service.MailService.*(..))")
    public Object doLogging(ProceedingJoinPoint pjp) throws Throwable {
        System.err.println("[Around] start " + pjp.getSignature());
        Object retVal = pjp.proceed();
        System.err.println("[Around] done " + pjp.getSignature());
        return retVal;
    }
}
```

配置类要加入**@EnableAspectJAutoProxy**注解，IoC容器看到这个注解，就会自动查找带有@Aspect的Bean，然后根据每个方法的@Before、@Around等注解把AOP注入到特定的Bean中。

```java
@Configuration
@ComponentScan
@EnableAspectJAutoProxy
public class AppConfig {
    ...
}
```

使用execution(* xxx.Xyz.*(..))这种方式覆盖面太大，有的不需要的方法也加入了切面，可以通过自定义注解来决定哪些方法需要加入切面，我们定义一个注解如下，

```java
@Target(METHOD)
@Retention(RUNTIME)
public @interface MetricTime {
    String value();
}
```

在需要被监控的方法上标注该注解，

```java
@Component
public class UserService {
    // 监控register()方法性能:
    @MetricTime("register")
    public User register(String email, String password, String name) {
        ...
    }
    ...
}
```

在Aspect中定义，

```java
@Aspect
@Component
public class MetricAspect {
    @Around("@annotation(metricTime)")
    public Object metric(ProceedingJoinPoint joinPoint, MetricTime metricTime) throws Throwable {
        String name = metricTime.value();
        long start = System.currentTimeMillis();
        try {
            return joinPoint.proceed();
        } finally {
            long t = System.currentTimeMillis() - start;
            // 写入日志或发送至JMX:
            System.err.println("[Metrics] " + name + ": " + t + "ms");
        }
    }
}
```

### 3.7.4 Spring

&emsp;&emsp;**Spring**框架提供了IoC容器和AOP，并支持基于Servlet的MVC开发、JDBC等数据访问模块、事务处理以及强大的第三方集成功能。

&emsp;&emsp;直接使用Servlet进行Web开发，比较繁琐，更好的方法是在Servlet基础上封装MVC框架，基于MVC开发Web应用，大部分时候，不需要接触Servlet API，开发省时省力，MVC框架主要有**Struts2**和**SpringMVC**等。

&emsp;&emsp;直接在JDBC上操作数据库，也比较繁琐，相应的封装好的框架有**Hibernate**和**MyBatis**等。

- SSH：Spring+Struts2+Hibernate
- SSM：Spring+SpringMVC+MyBatis
- SpringBoot：基于Spring的套件，它帮我们预组装了Spring的一系列组件，以便以尽可能少的代码和配置来开发基于Spring的Java应用程序，并内置了Tomcat服务器
- SpringCloud：基于Spring的套件，利用Spring Boot的自动配置，力图实现最简化的分布式应用程序开发

### 3.7.5 分层

&emsp;&emsp;在MVC架构中，执行流程为，Controller层访问数据，得到Model并将其传给View进行渲染。业务逻辑粘连了Controller层和Model层，应该从Controller层和Model层中解耦出来，成为独立的Service层，有利于业务逻辑的独立性和重复利用性。此外，与数据库交互的部分一般封装出DAO层。Controller层负责前后端交互，接收View层的请求，调用Service层，Service层使用DAO层获得数据Model，返回给Controller层，最后返回给View层。

- 表现层：Controller+View
- 逻辑层：Service
- 数据层：DAO+Model

参考：[谈谈service层在mvc框架中的意义和职责](https://www.imyangyong.com/blog/2019/11/%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5/%E8%B0%88%E8%B0%88Service%E5%B1%82%E5%9C%A8MVC%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E8%81%8C%E8%B4%A3/)

## 3.8 设计模式

- 单例模式：整个程序有且仅有一个实例，该类负责创建自己的对象，同时确保只有一个对象被创建

- 工厂模式：增加了创建对象时的封装层次

  - 简单工厂模式：一个工厂，通过向工厂传递类型来指定要创建的对象

  - 工厂方法模式：不同品牌设计不同的工厂

  - 抽象工厂模式：再加上不同的产品 前两种适合单一产品

- 观察者模式：被观察者类状态改变时，观察者类要采取相应的行动

## 3.9 测试

- 黑盒测试、灰盒测试、白盒测试
  - 黑盒测试法: 把程序看作一个黑盒子，完全不考虑程序的内部结构和处理过程。它只检查程序功能是否能按照规格说明书的规定正常使用，程序是否能适当地接收输入数据并产生正确的输出信息，程序运行过程中能否保持外部信息的完整性。黑盒测试又称为功能测试，包含等价类划分法、边界值法、错误推测法、因果图法等。
  - 灰盒测试：灰盒测试，是介于白盒测试与黑盒测试之间的一种测试，灰盒测试多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。灰盒测试不像白盒那样详细、完整，但又比黑盒测试更关注程序的内部逻辑，常常是通过一些表征性的现象、事件、标志来判断内部的运行状态。
  - 白盒测试法: 是把程序看成装在一个透明的白盒子里，测试者完全知道程序的结构和处理算法。这种方法按照程序内部的逻辑测试程序，检测程序中的主要执行通路是否都能按预定要求正确工作。白盒测试又称为结构测试，包含逻辑覆盖法和基本路径测试法。
- 系统测试、集成测试、单元测试
  - 系统测试：整个系统
  - 集成测试：测试模块间的组装和调用
  - 单元测试：测试模块内部

# 4 数据库

## 4.1 常见的数据库

- 关系型数据库(RDBMS)
  - MySQL
  - SQL Server
  - Oracle
- 非关系型数据库(NoSQL)
  - Key-Value数据库
    - Redis
  - 文档型数据库：数据以文档的形式存储，文档类似于Json，在爬虫和前端用的很多
    - MongoDB
  - 列存储数据库
    - HBase
    - ClickHouse
  - 图数据库

&emsp;&emsp;按存储位置，数据库还可分为传统的存在硬盘上的数据库和内存数据库，Redis就是内存数据库。

## 4.2 面试问题

**事物的四大特性**

- 原子性：要么执行，要么不执行
- 隔离性：所有操作全部执行完以前其它会话不能看到过程
- 一致性：事务前后，数据总额一致
- 持久性：一旦事务提交，对数据的改变就是永久的

**并发操作可能的问题**

- 脏读：一个事务读取了未提交事务执行过程中的数据
- 不可重复读：一个事务执行过程中多次查询返回不同查询结果
- 幻读：事务A修改了数据，事务B也修改了数据，这时事务A看来，明明修改了数据，咋不一样

**隔离级别**

|                | 脏读 | 不可重复读 | 幻读 |
| -------------- | ---- | ---------- | ---- |
| 读未提交       | √    | √          | √    |
| 读已提交       | ×    | √          | √    |
| 可重复读(默认) | ×    | ×          | √    |
| 可串行化       | ×    | ×          | ×    |

- 读未提交：一个事务没有提交，那么它所做的数据修改对其它事务也是可见的
- 读已提交：只有当事务提交了，事务对数据的修改才会对其它事务可见
- 可重复读：在一个事务使用某行的数据的过程中，不允许别的事务再对该行数据进行操作
- 可串行化：通过强制事务排序，使之不可能相互冲突

## 4.3 索引

&emsp;&emsp;数据的基本单位是块(大小一般是4K)，一个块里有很多行记录，数据库的读取方式是将整块数据从硬盘读到内存里，然后在内存中把块中的某行记录提取出来再进行使用。读取一整块称为一次I/O操作，一个查询的I/O次数越多，查询速度就越慢。

&emsp;&emsp;索引相当于目录，不使用索引只能一行一行扫描，使用索引可以直接定位，是一种空间换时间的方法，提高了查询速度，但增加了维护(删加改)时间。索引是加在字段上的，例如知道字段name的值是nju，然后得到整行数据的地址。索引相当于把字段值取出来作为Key，把该行的存储地址作为Value。

&emsp;&emsp;如下图，若把索引存在数组中，然后将索引排序，就可以通过二分查找快速找到要查询的值，但是数组的插入和删除时间复杂度很高，用链表又没法做二分查找，因此就有了B树和B+树。对于索引的排序，数值型字段可以直接排序，字符串这些是按ASCII等排序(底层存储还是二进制串，实际还是按二进制串排的，不同类型没有区别)。

<img src="C:\Users\Forest\AppData\Roaming\Typora\typora-user-images\image-20220105195043984.png" alt="image-20220105195043984" style="zoom:50%;" />

&emsp;&emsp;在设定主键时，会为主键也建立索引，称为聚集索引，对于其他字段的索引，称为非聚集索引，索引存的是对应的主键的值，然后通过主键的值找到该行的地址。

&emsp;&emsp;只有经常查询才需要建立索引，当查询很少、数据量很小或经常修改时不使用索引，如一个表只有四个块，全表扫描平均只需要两次I/O，加入索引反而变慢。

### 4.3.1 B树



### 4.3.2 B+树

3层，4次IO(3+1)

- 全键值Where	x=123
- 键值范围Where  45<x<123  
- 键前缀查找  where x LIKE ‘J%’

<img src="C:\Users\Forest\AppData\Roaming\Typora\typora-user-images\image-20220105203552253.png" alt="image-20220105203552253" style="zoom: 50%;" />

为什么说B+树比B树更适合数据库索引？
(1)B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。
(2)B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
(3)由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

### 4.3.3 哈希表

复杂度为1、不能排序、不能范围查

### 4.3.4 位图索引

&emsp;&emsp;BitMap Index，如果一个字段的可取值很少，如性别只有{男 女}两种取值，婚姻状况有{已婚 未婚 离婚}三种取值，对性别建立位图索引如下，

<img src="C:\Users\Forest\AppData\Roaming\Typora\typora-user-images\image-20220105180636309.png" alt="image-20220105180636309" style="zoom: 40%;" />

对每一行数据，1代表取该值，而0代表不取，同样，对婚姻状况建立索引如下，

<img src="C:\Users\Forest\AppData\Roaming\Typora\typora-user-images\image-20220105180702999.png" alt="image-20220105180702999" style="zoom:40%;" />

我们要找“男未婚”的行，只需将“男”和“未婚”这两列取与，为结果1的即我们需要的行，取与得到00100，因此第3行是我们需要的行。

&emsp;&emsp;对于可取值很多的字段，如身份证号，不适合建立位图索引，而适合用B树；相反，B树不适合可取值很少的字段，B树要求查询条件简单，返回结果少，创建B树的时间复杂度和空间复杂度高。

## 4.4 SQL

### 4.4.1 DDL

Data Definition Language，数据库定义语言

**数据库的操作**

- 显示所有数据库

  ```sql
  show databases;
  ```

- 使用某个数据库

  ```sql
  use 数据库名;
  ```

- 创建数据库

  ```sql
  create database 数据库名;
  ```

- 删除数据库

  ```sql
  drop database 数据库名;
  ```

**表结构的操作**

- 显示所有的表

  ```sql
  show tables;
  ```

- 显示某个表的结构

  ```sql
  describe 表名;
  ```

- 创建表

  ```sql
  create table 表名(字段名1 类型,字段名2 类型,...);
  create table students(id int(10),name varchar(10),password varchar(10));
  ```

- 删除表

  ```sql
  drop table 表名;
  ```

- 设置主键

  ```sql
  alter table 表名 add primary key(主键名);
  alter table students add primary key(id);
  ```

- 添加字段

  ```sql
  alter table 表名 add 新字段名 新字段的类型 after 已有的某个字段;
  alter table orders add isChoose int(1) after number;
  ```

- 更改字段的类型

  ```sql
  alter table 表名 modify column 已有字段的名 新类型;
  alter table students modify column id varchar(20);
  ```

- 更改字段名

  ```sql
  alter table 表名 change 旧字段名 新字段名 新字段类型;
  alter table myorder change id id1 varchar(20);
  ```

- 删除字段

  ```sql
  alter table 表名 drop column 字段名;
  alter table myorder drop column name;
  ```
  
- 视图(View)，例如我们要进行如下的操作，

  ```sql
  select name,contact 
  from customers,orders,oderitems
  where customers.id=orders.id 
  and orderitems.num=orders.num
  and prod_id='TNT2';
  ```

  如果我们要查询其他的prod_id，还要写一遍这样复杂的SQL，可以使用视图封装出一个虚拟表，

  ```sql
  create view product_customers as
  select name,contact,prod_id
  from customers,orders,oderitems
  where customers.id=orders.id 
  and orderitems.num=orders.num;
  ```

  然后我们就可以对虚拟表进行操作了，

  ```sql
  select name,contact
  from product_customers
  where prod_id='TNT2';
  ```

  视图只是对语句封装了一层，并不包含数据，实际上还是对原表进行操作的，使用视图有如下好处：复用SQL语句(可以方便地复用而不必知道基本查询细节)、保护数据(可以给用户授予表的特定部分的访问权限而不是整个表的访问权限)、更改数据格式和表示(视图可返回与底层表的表示和格式不同的数据)。

### 4.4.2 DML

Data Manipulation Language，数据操纵语言

- 插入数据

  ```sql
  insert into 表名 values(值1,值2,值3);
  insert into students values(1,'张三','123');
  ```

- 更新数据

  ```sql
  update 表名 set 字段名=值 where ...;
  update orders set number=7 where number=10 and dorm='明理居';
  ```

- 查询数据

  ```sql
  select * from 表名 where ...;
  ```

  查询时去掉重复的内容，如原来country有CN、UK、UK，现在查询结果为CN、UK

  ```sql
  select distinct 字段 ...;
  select distinct country from customers;
  ```

- 删除行

  ```sql
  delete from 表名 where ...;
  ```

- 排序，默认升序asc，降序desc

  ```sql
  order by 字段名
  select * from students order by score;
  select * from students order by score desc;
  ```

- 限制结果的查询行数，下标从0开始

  ```sql
  limit [起始位置,]数量;
  limit 数量 offset 起始位置;
  limit 3,4;  #从行3开始，共4行
  limit 4 offset 3;  #同上
  ```

- 聚合：对某列求count max min sum avg

  ```sql
  select avg(price) as avg_price from orders;
  select count(*) as num_order from orders;  #求表中的总行数，包含NULL
  select count(字段) as num_order from orders;  #不包含总行数
  select count(price) as num_order from orders where p
  ```
  
- 分组+聚合：按某字段分组，并用聚合函数操作

  ```sql
  group by 字段
  select id,sum(price) from order group by id;
  select id,count(*) from order group by id;
  ```

  筛选满足一定的条件，用having，而不是where，前者是对一组，后者是对一行

  ```sql
  having 条件
  select id,count(*) from order group by id having count(*)>=2; 
  ```

- 内连接：先求积，再找满足条件的

  ```sql
  表1 join 表2 on 条件
  ```

- 左外连接：左表每一行都有，右表满足条件的加上，不满足的空

  ```sql
  表1 left join 表2 on 条件
  ```

- 右外连接：右表每一行都有，左表满足条件的加上，不满足的空

  ```sql
  表1 right join 表2 on 条件
  ```

- 全外连接：左右两行都有，左右外连接的合并

  ```sql
  表1 full join 表2 on 条件
  ```

- 自然连接：相同属性的值相同时连接，没有`on`

  ```sql
  表1 natural join 表2
  ```

- 查看语句的执行计划

  ```sql
  explain 语句;
  ```

### 4.4.3 其他

- 登录，在安装目录的bin目录下

  ```sql
  mysql -u root -p
  ```

- 输入不正确语句时退出语句

  ```sql
  "\c或'\c
  ```

- 刷新权限

  ```sql
  flush privileges;
  ```

# 5 计算机网络

**计算机网络层次**

- 应用层：HTTP DNS (为主机的应用程序提供网络服务)
- 传输层：TCP UDP (在不同主机的进程之间传输报文段)
- 网络层：IP 路由器 (在主机之间传输IP数据报)
- 链路层：交换机 (在相邻节点之间传输帧)
- 物理层：中继器 集线器 网关 (在节点之间传输比特流)

**面向连接和无连接**

- 面向连接：可靠，通信前后要建立和拆除连接，保证从发送方发出的数据，最终完整正确地交付给接收方

  - 可靠的数据传输：接收端收到分组时，要返回确认，长时间未收到则重传

  - 流量控制：控制发送速度，使接收方来得及接收(接收方缓存满时降低发送速率)
  - 拥塞控制：控制发送速度，使得网络来得及转发(当网络出现拥塞即丢包时降低发送速率)

- 无连接：不可靠，不对交付质量作任何保证，效率高

**TCP和UDP**

- TCP：面向连接，点对点，字节流，三次握手(若只有两次握手，服务端无法确认客户端能正常接收数据)，四次挥手(前两次是确认客户端没有数据要发送，后两次是确认服务端没有数据要发送)
  - 三次握手：客户端→服务端 服务端→客户端 客户端→服务端
  - 四次挥手：客户端→服务端 服务端→客户端 服务端→客户端 客户端→服务端
- UDP：无连接，一对一，一对多，多对一，多对多，报文


**HTTP和HTTPS**

- HTTP：运行在TCP上，明文传输，客户端与服务端都无法验证对方身份，端口80
- HTTPS：运行在SSL上，SSL运行在TCP上，添加了加密和认证机制，端口443

**GET和POST**

- GET：向服务器请求一个实体对象，如页面
- POST：向服务器传数据,如登录、提交表单

**Cookie和Session**

- Cookie：HTTP本身是无状态的，服务器无法判断用户身份，客户端可以用Cookie(不是缓存)保存用户信息，允许Web应用跟踪识别用户(如存储用户名密码，存储购物车商品等)。例：去银行办理储蓄业务,第一次给你办了张银行卡，里面存放了身份证、密码、手机等个人信息。当你下次再来这个银行时，银行机器能识别你的卡，从而能够直接办理业务。
  1. 客户端第一次请求；
  2. 服务器应答，头部包含Set-Cookie；
  3. 客户端将Cookie存储在本地磁盘；
  4. 之后的请求的头部包含Cookie；
  5. 服务器识别应答
- Web缓存：在服务器和客户机之间
- Session：Cookie不够安全,别人得到你的Cookie就能得到你的用户名和密码，因此有了Session机制。Session相当于在Cookie的基础上又封装了一层。
  - 客户端第一次请求；
  - 服务器根据用户名和密码，生成一个SessionID存储在服务器的数据库中，并在应答时将其发给用户；
  - 之后的请求将该SessionID作为Cookie的一部分发送；
  - 服务器收到请求后，通过Cookie中的SessionID到数据库中查询，解析出用户名和密码等

**常见协议**

- FTP：文件传输协议，基于TCP，本地主机向远程主机上传或者下载文件，与HTTP传文件区别：FTP有两个TCP连接，一个控制连接一个数据连接，FTP存储用户状态而HTTP不
- SMTP：简单邮件传送协议，基于TCP，从发送方向发送方邮件服务器发邮件，从发送方邮件服务器向接收方邮件服务器发邮件，与HTTP区别：HTTP是想获得文件的设备发起，SMTP是要发送文件的设备发起
- POP3 IMAP HTTP：用邮件服务器读邮件

**DNS和ARP**

- DNS：实现主机名(域名)和IP地址的相互转换，基于UDP
- ARP：根据IP地址获得MAC地址，基于TCP

**在浏览器输入URL地址→显示主页的过程**

http://fex.baidu.com/blog/2014/05/what-happen/

- 输入URL时会根据历史输入统计来预估所输入字符对应的网站，在回车前可能就建立TCP连接甚至渲染了
- 对网址做格式化的检查
- 查询自身缓存，有并且未过期就直接返回数据
- 若未指明协议则默认使用HTTP协议
- 查询DNS，得到IP地址(内存DNS Cache→硬盘host文件→DNS服务器)
- 利用ARP，根据IP地址得到MAC地址
- 向目标服务器发送HTTP请求，建立TCP连接
- 服务器处理请求并返回HTTP响应，所需资源就在响应报文中
- 浏览器解析渲染页面并显示给用户

# 6 操作系统



# 7 Linux

## 7.1 概述

Linux系统的组成

- 内核
- Shell
- 文件系统
- 应用程序

Linux主流发行版本(将内核和一些应用程序、文档包装起来，再提供一些配置管理工具等就构成了发行版本)

- Red Hat
- CentOS
- Ubuntu
- Debian

防火墙

- iptables：在Red Hat6及之前使用的
- firewalld：Red Hat7使用的，iptables是静态的，每次修改都要求防火墙完全重启，现在firewalld可以动态 管理防火墙，支持动态配置，不用重启服务

Linux系统启动过程

- BIOS自检
- 启动GRUB 2(引导加载程序)
- 加载内核映像到内存中
  - 检测所有硬件设备
  - 驱动硬件设备
  - 以只读的方式挂载根文件系统
  - 启动systemd服务
- 执行systemd进程，systemd进程是所有进程的发起者和控制者，是系统运行的第一个进程，永远不会停止
- 初始化系统环境
- 执行/bin/login程序，等待登录

## 7.2 常用命令

**控制组合键**

- Ctrl+C：终止命令
- Ctrl+Z：挂起命令
- Ctrl+L：清屏

**关机/重启命令**

- shutdown：关机(-h)或重启(-r)

  ```
  shutdown -h now 现在关机
  shutdown -h +45 45分钟后关机
  shutdown -r 01:38 1点38重启
  ```

- halt：关机

- reboot：重启

- poweroff：关机并切断电源

**获取帮助**

- man

  ```
  man mkdir
  ```

- --help

  ```
  mkdir --help
  ```

- Tab：命令自动补全

- history：查看历史命令

**命令排列**

- 命令1;命令2：先执行命令1再执行命令2，而不管命令1是否出错
- 命令1&&命令2：只有当命令1正确执行完毕后，才执行命令2

**命令别名**

- alias 别名＝需要定义别名的命令：命令中若有空格需要加双引号
- unalias 别名：取消别名
- 文件名匹配：*可以匹配多个字符，?只能匹配一个

**命令替换**

- 命令1 $(命令2)：命令2的结果作为命令1的参数
- 命令1 \`命令2\`：命令2的结果作为命令1的参数，其中`是Tab上面的键

- !$：前一个命令最后的参数

  ```
  mkdir /root/aaa
  cd !$
  相当于 cd /root/aaa
  ```

**管道**

- 命令1|命令2|...：将前一个命令的输出信息作为后一个命令的输入

**重定向**

- 命令>文件：输出重定向，将命令的输出保存到文件中，如果已经存在相同的文件，那么覆盖原文件中的内容

  ```
  echo Hello > /root/mm
  ```

- 命令>>文件：输出追加重定向，将命令的输出追加到已经存在的文件中

- 命令<文件：输入重定向，将某一文件的内容作为命令的输入

- 命令<<文件：输入追加重定向

  ```
  [root@~]#cat > /root/bc <<EOF
  >Hello Linux
  >Hello World
  >EOF
  ```

- 命令2>文件：错误重定向，将某一命令执行的出错信息输出到指定文件中

- 命令2>>文件：错误追加重定向，将某一命令执行的出错信息追加到已经存在的文件中

- 命令&>文件：输出+错误重定向

**vi/vim编辑器**

- vim是vi的增强版

- 命令模式：vi+文件名默认进入命令模式，可以控制屏幕光标的移动，字符、字或行的删除，某区域的移动、复制等

- 插入模式：在命令模式下按i(从光标当前所在位置之前开始插入)或a(之后)进入插入模式，该模式下可以进行文本编辑，按Esc返回命令模式

- 末行模式：在命令模式下按:进入末行模式，该模式下可以保存文件或退出编辑器，按Esc返回命令模式，其中

  ```
  :w 保存文件
  :q 退出编辑器
  :wq 保存文件并退出编辑器
  :wq! 保存文件并强制退出编辑器
  ```

**文本内容显示**

- cat [选项] [文件名]：显示文件内容，或将一个文件的内容输出到另一个文件中

  ```
  cat /etc/inittab 显示文件内容
  cat /root/file1 > /root/file2 将file1的内容输出到file2
  -n 代表加上行号
  ```

- more [选项] [文件名]：分页显示文件内容，按空格下一页，按b上一页

  ```
  -s 合并空行
  +n 从第n行开始显示
  -n 一次显示n行
  ```

- less [选项] [文件名]：与more类似，还可以往回卷动

- head [选项] [文件名]：显示文件前若干行，默认10行

  ```
  -n 前n行
  -c 按字节
  ```

- tail [选项] [文件名]：显示文件末尾若干行，默认10行

  ```
  -n 前n行
  -c 按字节
  ```

**文本内容处理**

- sort [选项] [文件名]：对文件内容进行排序

  ```
  -r 倒序
  ```

- uniq [选项] [文件名]：报告或删除文件中**相邻**的重复行，要先排序

  ```
  -d 查看重复的行
  -u 查看不重复的行
  ```

- cut [选项] [文件名]：从文件每行中显示出选定的字节、字符或字段

  ```
  -b 字节
  -c 字符
  -f 字段
  cut -f 5 /etc/passwd 显示文件中的第5个字段
  ```

- comm [选项] [文件1] [文件2]：逐行比较两个已排过序的文件

  ```
  -1 不输出文件1特有的行
  -2 不输出文件2特有的行
  -3 不输出两个文件共有的行
  ```

- diff [选项] [文件1] [文件2]：逐行比较两个文件，列出其不同之处，不要求事先排序

**查找**

- grep [选项] [查找内容] [文件名]：查找文件中符合条件的字符串

  ```
  grep 'aaa' file1 在file1中搜索匹配字符aaa
  ps –ef|grep sshd 查找进程sshd的信息
  ```

- find [路径] [选项]：列出文件系统内符合条件的文件

  ```
  find /boot -name '*.conf' 查找/boot下以.conf为扩展名的文件
  ```

- locate [选项] [文件]：在数据库中查找文件，数据库每天更新，比find快

**系统信息显示**

- free：查看内存信息(物理内存和swap的使用情况)
- du：查看目录或文件的磁盘占用量
- df：磁盘使用情况/挂载情况统计

**任务计划**

- 在固定的时间上触发某个作业
- root用户修改/etc/crontab文件或在/etc/cron.d目录下创建文件
  - minute hour day month dayofweek username commands
  - 45 4 1,10,22 * * root /root/backup.sh 在每月1、10、22日的4:45执行/root/backup.sh文件
- 普通用户使用crontab命令
  - crontab -e：编辑当前用户的crontab，文件保存在/var/spool/cron下，文件名为用户名
  - crontab -u 用户名 -l：列出
  - crontab -u 用户名 -r：删除
  - crontab [文件]：恢复

**NFS(Network File System)**

- NFS用于对在同一个网络上的多个用户之间共享目录和文件

- 共享目录的配置在/etc/exports文件中，文件默认为空

- 共享目录 客户端(导出选项)

  - 共享目录必须使用绝对路径，且该目录需事先创建好

  - 客户端可以是一台计算机，也可以是一个网段，甚至是一个域

  - 导出选项

    ```
    rw 共享目录具有读取和写入的权限
    ro 共享目录具有只读的权限
    sync 所有数据在请求时写入共享，在请求所做的改变被写入磁盘之前就不会处理其它请求，适合大量写请求
    ```

  - /it 192.168.0.5(ro,sync)  允许来自主机192.168.0.5的用户以只读权限来挂载/it目录

## 7.3 文件和分区

### 7.3.1 文件

文件类型

- 普通文件：-

- 目录文件：d

- 设备文件

  - 块设备文件(磁盘)：b
  - 字设备文件(打印机和终端)：c

- 管道文件：p

- 链接文件：l

  - 内核为每一个新创建的文件分配一个inode(索引节点)号，文件属性保存在inode里，在访问文件时，inode被复制到内存里，从而实现文件的快速访问

  - 硬链接：硬链接是一个指针，指向另一个文件的inode，系统并不为它重新分配inode，两文件具有相同的inode，不允许给目录创建硬链接，且只有在同一文件系统中的文件之间才能创建硬链接

  - 软链接：又称符号链接，指向另一个文件的路径，类似Windows下的快捷方式，可以链接不同文件系统的文件

  - ln [选项] [源文件名] [链接文件名]

    ```
    默认硬链接
    -s 软链接
    ```

权限

- 对一个文件或目录来说，有三种用户的访问权限，文件所有者(默认为创建者)、所有者所在组群、其他用户

- chmod [操作对象] [操作符号] [权限] [文件|目录]：设置访问权限

  - 操作对象

    ```
    u 文件所有者owner
    g 所有者所在组群group
    o 其他用户other
    a 所有用户all
    ```

  - 操作符号

    ```
    + 添加某个权限
    - 取消某个权限
    = 赋予给定权限并取消原先权限
    ```

  - 权限

    ```
    r 读取
    w 写入
    x 执行
    ```

  - drwx--x--x：d代表文件类型是目录文件，rwx代表文件所有者有读写执行权限，--x代表组群其他用户只有执行权限，--x代表其他所有用户只有执行权限

  - chmod u+w a：给文件a所有者增加写入权限

- chmod [-R] [n1n2n3] [文件|目录]：数字设定法设定权限，n1、n2、n3分别代表u、g、o三种用户

  ```
  -R 对目录及目录下的所有文件
  r 4
  w 2
  x 1
  - 0
  ```

  - -rwxr--r--：用数字表示为744
  - drwx------：用数字表示为700

- 特殊权限

  - SUID：对一个可执行文件，不是以发起者身份来获取资源，而是以可执行文件的用户所有者身份来执行；对一个目录无影响；数字表示法为4

  - SGID：对一个可执行文件，不是以发起者身份来获取资源，而是以可执行文件的组群所有者身份来执行；对一个目录，在该目 录中创建的任意新文件的所属组与该目录的所属组相同；数字表示法为2

  - Sticky：对一个可执行文件无影响；对目录设置Sticky之后，尽管其它用户有写权限，也必须由文件所有者执行删除和移动等操作；数字表示法为1

  - ```
    chmod 4000 a 对文件a设置SUID权限
    ```

- chown [选项] [用户.组群] [文件|目录]：更改文件所有者和组群所有者

### 7.3.2 磁盘分区

&emsp;&emsp;在Linux系统中，要在某个磁盘上存储数据，首先需要进行磁盘分区，然后创建文件系统(格式化)，最后将文件系统挂载到目录下。

- 磁盘分区

  - 磁盘分区是指对硬盘的逻辑划分，磁盘分区有利于对文件的管理，防止文件丢失，不同的分区还可以安装不同的操作系统。磁盘分区分为主分区、扩展分区和逻辑驱动器。主引导记录(MBR)包含一个64字节的硬盘分区表，由于每个分区信息需要16个字节，因此最多四个主要分区，一般4个主分区或3个主分区+1个扩展分区，扩展分区中记录多个逻辑驱动器的地址。

  - 分区的命名方案为/dev/xxyN

    ```
    /dev：Linux系统中所有设备文件所在的目录名(Linux一切皆文件，设备也是通过文件的方式来表现和使用的)
    xx：分区名的前两个字母表示分区所在设备的类型，通常是hd(IDE硬盘)或sd(SCSI硬盘)
    y：这个字母表示分区所在的设备，例如/dev/hda(第1个IDE硬盘)或/dev/sdb(第2个SCSI硬盘)
    N：最后的数字N代表分区，前4个分区(主分区或扩展分区)用数字1～4表示，逻辑驱动器从5开始，例如/dev/hda3是第1个IDE硬盘上的第3个主分区或扩展分区；/dev/sdb6是第2个SCSI硬盘上的第2个逻辑驱动器
    ```

  - 分区类型

    ```
    普通分区
    RAID分区(磁盘阵列)
    LVM分区(逻辑卷)
    SWAP分区(交换分区)
    ```

  - fdisk：分区创建

    ```
    p 显示分区信息
    n 创建新的分区
    p 创建主分区
    e 创建扩展分区
    w 保存分区设置并退出
    ```

  - partprobe：更新分区表

- 创建文件系统(格式化)

  - 将现有的分区中所有的数据清除，建立磁道和扇区，使用较多的文件系统有xfs和ext4。
  - mkfs [选项] [设备]
  - mkfs -t ext4 /dev/sda5

- 将分区的文件系统挂载到目录上

  - 如果将目录/usr挂载到分区/dev/sda5上，这意味着所有在/usr下的文件和目录在物理上位于/dev/sda5

  - mount [选项] [设备] [挂载目录]：挂载

    ```
    -o ro 只读
    -o rw 读写
    ```

  - umount [选项] [设备|挂载目录]：卸载

  - 开机自动挂载，修改/etc/fstab文件

    ```
    设备名 挂载目录 文件系统类型 挂载选项(ro/rw/defaults) 转储选项(0备份/1不备份) 文件系统检查选项
    ```

### 7.3.3 目录结构

<img src="C:\Users\Forest\AppData\Roaming\Typora\typora-user-images\image-20211215142057335.png" alt="image-20211215142057335" style="zoom: 80%;" />

- /：Linux系统的根目录，所有的目录都挂在这个目录下面，建议大小最少为10GB
- /boot：用来存放与Linux系统启动有关的程序，比如引导装载程序等，最少200MB
- /usr：用来存放Linux系统中的应用程序，其相关数据较多，建议大小最少为8GB
- /var：用来存放Linux系统中经常变化的数据以及日志文件，建议大小最少为1GB
- /home：存放普通用户的数据，是普通用户的主目录，建议大小为剩下的空间
- /root：root用户的主目录
- /etc：配置文件
- /bin：包含常用的命令文件，不能包含子目录
- /sbin：包含系统管理员和root用户所使用的命令文件
- /dev：包含大部分的设备文件，比如磁盘、光驱等
- /lib：包含Linux系统的共享文件和内核模块文件，/lib/modules目录存放核心可加载模块
- /tmp：包含一些临时文件
- /opt：放置第三方的软件

### 7.3.4 文件操作命令

- pwd：显示用户当前所处工作目录的绝对路径

- cd [目录]：更改工作目录路径

  - cd 切换到用户主目录/root或者/home/用户名

    ```
    [用户名@主机名 ~]
    ```

  - cd ~ 同上

  - cd / 切换到根目录/

    ```
    [用户名@主机名 /]
    ```

  - 在任何目录下，创建目录mkdir /abc，都代表在根目录下创建，而mkdir abc才代表在当前目录下创建，前者是绝对路径，后者是相对路径

- ls：列出目录和文件信息

  ```
  -l 显示详细信息
  ```

- touch：创建空文件

- mkdir：创建目录

  ```
  -p 递归地创建目录，即使上级目录不存在，也会按目录层级自动创建目录，如果直接mkdir /a/b而a不存在就会错
  ```

- cp [选项] [源文件|目录] [目标文件|目录]：复制文件/目录

  ```
  -r 对目录中的所有文件及其子目录负责
  如果是目标文件，若文件已存在，则会破坏，若不存在，则为改名
  如果是目标目录，则是将内容复制到该目录下
  ```

- mv [选项] [源文件|目录] [目标文件|目录]：移动文件/目录或改名

- rm：删除文件

- rm -r：递归地删除目录及其目录下的内容

- -f：是否询问

- wc：统计文件行数、单词数和字节数


### 7.3.5 交换分区

&emsp;&emsp;直接从物理内存读写数据要比从硬盘读写数据快的多，而物理内存是有限的，这样就使用到了虚拟内存，它是利用磁盘空间虚拟出的一块逻辑内存，称为交换分区(SWAP分区)。建议大小是物理内存的1～2倍。

&emsp;&emsp;内核会将暂时不用的内存块信息写到交换分区，这样一来，物理内存得到了释放，这块内存就可以用于其它用途，当需要用到原始的内容时，这些信息会被重新从交换分区读入物理内存。Linux系统会不时地进行页面交换操作，以保持尽可能多的空闲物理内存，即使并没有什么操作需要使用内存， Linux也会交换出暂时不用的内存页面，这可以避免等待交换所需的时间。一般使用“最近最常使用”算法。

### 7.3.6 LVM逻辑卷管理

 &emsp;&emsp;Logical Volume Manager，屏蔽了底层磁盘布局，便于动态调整磁盘容量，解决硬盘设备在创建分区后不易修改分区大小的缺陷。其中/boot用于存放引导文件，不能应用LVM机制。

- PV(Physical Volume)：物理卷，整个硬盘或使用fdisk等工具建立的磁盘分区，包括许多PE(基本单元)，PE默认大小4MB
- VG(Volume Group)：卷组，一个或多个物理卷组合而成的整体
- LV(Logical Volume)：逻辑卷，从卷组中分割出的一块空间，用于建立文件系统

<img src="C:\Users\Forest\AppData\Roaming\Typora\typora-user-images\image-20211213141011124.png" alt="image-20211213141011124" style="zoom: 50%;" />

创建逻辑卷的步骤

- 用fdisk等工具创建新的磁盘分区，如/dev/sda7

- 将创建的新的磁盘分区创建为物理卷，pvcreate 设备名

  ```
  pvcreate /dev/sda7
  ```

- 创建卷组，vgcreate -s PE块大小 卷组名 物理卷设备名1 物理卷设备名2

  ```
  vgcreate -s 8m wgroup /dev/sda7
  ```

- 创建逻辑卷，lvcreate -n 逻辑卷卷名 -L 逻辑卷大小 卷组名

  ```
  lvcreate -n wshare -L 800m wgroup
  ```

- 格式化逻辑卷，mkfs -t 文件系统类型 /dev/卷组名/逻辑卷卷名

  ```
  mkfs -t ext4 /dev/wgroup/wshare
  ```

- 用mount挂载到目录

  ```
  mount /dev/wgroup/wshare /abc
  ```

- 扩大逻辑卷，扩大前要看卷组够不够，lvextend -L 改变的大小 /dev/卷组名/逻辑卷卷名

- 缩小逻辑卷，缩小前要先将逻辑卷卸载，lvreduce -L 改变的大小 /dev/卷组名/逻辑卷卷名

## 7.4 Shell

&emsp;&emsp;Shell既是一种命令语言，交互式地解释和执行用户输入的命令，即我们在终端输入的命令；又是一种程序设计语言，可以定义各种变量和参数，并提供了循环和分支等控制结构。流行的Shell 有sh、csh 、ksh、tcsh 和bash等，大部分Linux系统的默认Shell类型为bash，bash是sh的超集。一个命令如果是bash内置的命令，则由bash负责回应，如果是应用程序，那么Shell会找出该应用程序，然后将控制权交给内核，由内核执行该应用程序，执行完之后，再将控制权交回给Shell。

### 7.4.1 Shell编程

- 脚本第一行必须是

  ```bash
  #! /bin/bash
  ```

  其中#!用来告诉系统它后面的参数是用来执行该脚本的程序，即用bash执行

- 要使脚本可以执行，需要赋予该文件可执行的权限，chmod +x [文件名]

- #表示注释

- 通过$变量名来获取变量的值

  ```
  a=5
  echo $a  #输出5
  name="南京"
  echo $name #输出南京
  ```

- 预定义的一些环境变量

  ```bash
  $HOME 用户主目录的完整路径
  $PWD 当前工作目录的完整路径
  $UID 用户的UID
  ```

- readonly 变量名：使该变量只读

- export 变量名：使该变量在Shell以后运行的所有 命令或程序中都可以访问到

- \$1 \$2 \$3：命令行中的输入参数，按顺序

- 字符串比较

  ```
  = 比较两个字符串是否相同
  != 比较两个字符串是否不同
  -n 字符串长度是否大于0
  -z 字符串长度是否等于0
  ```

- 数字比较

  ```
  -eq 等于
  -ge 大于等于
  -le 小于等于
  -ne 不等于
  -gt 大于
  -lt 小于
  ```

- 逻辑测试

  ```
  -a 与
  -o 或
  ! 非
  ```

- 数学计算

  ```bash
  `expr 计算式`
  a=`expr 2+2`  #a=4
  b=`expr $a +3` #b=a+3=7
  
  \* 乘法
  ```

- if语句

  ```bash
  if [ 条件 ]
  then 命令行
  fi
  
  if [ 条件 ]
  then 命令行
  else 命令行
  fi
  
  例：
  if [ $n -ge 10 ]
  then echo "大于"
  else echo "小于"
  fi
  ```

- case语句

  ```bash
  case 变量 in
  值1)
  	命令行
  ;;
  值2)
  	命令行
  ;;
  *)
  命令行
  esac
  
  例：
  a=2
  case $a in
  1)
  	echo "a=1"
  ;;
  2)
  	echo "a=2"
  ;;
  *)
  	echo "a"
  esac
  ```

- for循环

  ```bash
  for 变量名 in 数值列表
  do
  	命令行
  done
  
  例：
  for a in 1 2 3 4
  do
  	echo $a
  done
  ```

- while循环，条件为真时继续循环

  ```bash
  while [ 条件 ]
  do
  	命令行
  done
  
  例：计算1~5的平方
  index=1
  while [ $index -le 5 ]
  do
  	sq=`expr $le \* $le`
  	echo $sq
  	index=`expr $index + 1`
  done
  ```

- until循环，条件为假时继续循环

  ```bash
  until [ 条件 ]
  do
  	命令行
  done
  ```

## 7.5 用户和组群

### 7.5.1 用户

/etc/passwd存用户，/etc/shadow存密码

- root用户：UID为0，用户权限最高

- 系统用户：UID为1~999，是系统自身拥有的，不具有登录Linux系统的能力

- 普通用户：UID为1000~60000，是root用户创建的，可以分配不同的权限

- useradd [选项] [用户名]：在系统中创建一个新账户，需要设定密码才能用

  ```
  -u 设置UID
  -d 设置主目录
  -g 指定群组
  -s 指定shell类型
  ```

- usermod [选项] [用户名]：修改用户账户

  ```
  -u 修改UID
  -d 修改主目录
  -g 修改群组
  -s 修改shell类型
  -l 修改登录名
  -c 修改全名
  -f 密码过期后⼏天禁⽤账户
  -L 锁定账户密码
  -U 解锁账户密码
  -e 修改账户过期⽇期
  ```

- uesrdel [选项] [用户名]：删除用户账户

  ```
  -r 同时删除主目录，默认不删除
  ```

### 7.5.2 组群

- 私有组群：当创建一个新的用户账户时，如果没有指定该用户属于哪一个组群，那么Linux就会创建一个和该用户同名的组群，这个组群就是私有组群，在这个私有组群中只包含这个用户

- 标准组群：可以包含多个用户账户，当创建一个新的用户账户时，指定该用户属于哪一个组群。同一组群中的用户有相同的特征，如访问权限和分配管理任务等

- groupadd [选项] [组群名]：创建组群

  ```
  -g 设置GID
  -r 设置系统组群
  ```

- groupmod [选项] [组群名]：修改组群账户

  ```
  -g 修改GID
  -n 修改组群名
  ```

- groupdel [组群名]：删除组群

### 7.5.3 账户维护

- passwd [选项] [用户名]：设置密码

  ```
  -l 锁定
  -u 解锁
  -d 删除
  ```

- su：切换到其他用户登录

- sudo：

- newgrp：让用户账户以另一个组群的身份进行登录

- groups：查看用户属于哪些组群

- id：查看用户UID和GID

## 7.6 RPM(RedHat Package Manager)

### 7.6.1 用rpm管理RPM软件包

- 安装：rpm -ivh [RPM包文件名称]
- 删除：rpm -e [RPM包名称]
- 升级(删除+安装，不管之前是否已安装都安装)：rpm -Uvh [RPM包文件名称]
- 刷新(若版本比之前已安装的高则安装，若之前没安装则不装)：rpm -Fvh [RPM包文件名称]
- 查询某包是否安装：rpm -q [RPM包名称]
- 查询所有已安装的包：rpm -qa
- 查询包的信息：rpm -qi [RPM包名称]
- 查询包的文件列表：rpm -ql [RPM包名称]
- 查询包的依赖关系：rpm -qR [RPM包名称]
- 查询指定文件属于哪个包：rpm -qf [文件名]

### 7.6.2 用yum管理RPM包

- 使用rpm，当删除某个包时，可能导致其他包缺少依赖
- yum能收集RPM软件包的相关信息， 检查依赖性并且一次安装所有依赖的软件包，yum要有软件仓库

- yum [选项] [包名]：

  ```
  list 列出已安装的软件包
  info 详细信息
  install 安装
  remove 删除
  update 升级
  ```

### 7.6.3 tar包

- tar命令可以将一大堆文件和目录打包成一个文件，然后压缩，也可以打包后调用其他压缩程序压缩

- tar [选项] [文件|目录]

  ```
  cvf 压缩
  tvf 查看内容
  xvf 解压
  rvf 添加
  z 调用gzip，即变成zcvf，压缩成*.tar.gz
  ```

## 7.7 进程

&emsp;&emsp;systemd进程是系统启动后的第一个进程，PID为1，其余的进程都必须由已存在的进程来创建，新创建的进程叫做子进程，而创建子进程的进程叫做父进程。

- 进程分类

  - 交互式进程：一个由Shell启动并控制的进程，交互式进程既可在前台运行，也可在后台运行
  - 批处理进程：与终端无关，安排在指定时刻完成的一系列进程
  - 守护进程：在引导系统时启动，以执行即时的操作系统任务，比如crond、rsyslogd、 named等
  
- ps [选项]：查看进程信息

  ```
  -a d
  -e 显示所有进程
  -u 用户名
  -p 进程号
  ```

- jps：查看Java进程

- top：显示当前正在运行的进程及其相关信息

- kill [选项] [进程号]：杀死进程

  ```
  -9 强制杀死
  ```

## 7.8 网络

- 网络设备的配置文件：/etc/sysconfig/network-scrip

- 域名解析器使用的配置文件：/etc/resolv.conf

- 在可以查询DNS之前，存放主机名到IP地址的映射：/etc/hosts

- 定义了所有的服务名称、协议类型、服务端口：/etc/services

- traceroute [选项] [主机名|IP地址] [数据包大小]：traceroute [选项] [主机名|IP地址] [数据包大小]

- ifconfig：显示和配置网络接口

  ```
  ifconfig eth0 up/down 启动/关闭网卡
  ifconfig eth0 192.168.1.56 给网卡配置IP地址
  ifconfig eth0 192.168.1.56 netmask 255.255.255.0  给网卡配置IP地址并加上子网掩码
  ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE 修改MAC地址
  ```

- ping [选项] [目标]：测试连通性

  ```
  -s 数据包大小
  ```

- netstat：显示网络状态

- arp [选项] [IP地址] [MAC地址]：增删改查ARP缓存条目

  ```
  -s 新增
  -d 删除
  ```

- tcpdump：抓包

- systemctl [选项] [单元命令|单元文件命令]：管理网络服务

  ```
  start 启动
  stop 停止
  restart 重新启动
  reload 重新加载
  enable 开机自启
  disable 取消开机自启
  is-enable 是否开机自启
  status 查看服务状态
  list-unit --type=service 查看所有已启动服务
  ```

  - systemctl start named.service

## 7.9 远程连接

- ssh [-p 端口] 用户@主机地址 [命令]：远程连接

  ```bash
  ssh zhangsan@192.168.0.100
  ssh root@192.168.0.100 ls /boot
  ```

- scp [[用户@]主机1:]文件1 [[用户@]主 机2:]文件2：远程传送文件

  ```bash
  scp /root/a root@192.168.0.100:/root/b
  ```


# 8 项目合集

- TrendMicro字符串可读性检测  机器学习
- Hadoop/Spark高光谱图像处理 大数据应用
- ~~字节镜像计划设计实现一个MapReduce和分布式KV系统 大数据组件开发~~
- 社交网络的博彩账号检测 爬虫+数据挖掘+机器学习
- ~~爬虫商品比价 爬虫+后端~~
- k分搜索的时间复杂度分析 论文



1.介绍一下论文
论文是k分搜索的时间复杂度分析，搜索是指在一个排好序的数组中寻找与给定数值相等的元素，二分搜索是将数组每次分为相等的两部分，k分搜索则是分为k部分，这篇论文在二分搜索的基础上推导出三分，直到k分搜索的复杂度，得出 k 分搜索的时间复杂度为O(klogkn)，由于该函数是递增的，因此二分搜索是效率最高的搜索算法，此外，当k=n时，k分搜索退化为遍历，复杂度退化为O(n)。
论文是大二写的，当时的想法还比较浅吧
这篇论文是大二算法课的大作业上写的，当时老师说写的挺好，然后今年假期有时间就重新写了写，也练习了一下论文写作吧。
(证明可以把搜索过程想象成二叉树 第一次20 第二次21 第三次22)
2.论文的应用？
证明了二分搜索是k分搜索是最快的吧，本来的想法是，如果有比二分搜索更快的算法，就可以对二叉搜索树等二分搜索的应用进行优化了吧，最后证明二分搜索最快就说明这些所发不需要再优化了吧。这篇文章更多还是理论证明，实际应用薄弱了一点。 
